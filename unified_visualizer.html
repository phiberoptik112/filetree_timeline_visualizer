<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified File Tree & Milestone Timeline Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f1419 100%);
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #threejs-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #threejs-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 50% 50%, rgba(74, 144, 226, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: 1;
        }

        #threejs-container canvas {
            position: relative;
            z-index: 2;
        }

        .panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            z-index: 100;
            max-height: 80vh;
            overflow-y: auto;
        }

        #control-panel {
            top: 20px;
            left: 20px;
            max-width: 350px;
        }

        #info-panel {
            top: 20px;
            right: 20px;
            max-width: 350px;
        }

        #timeline-controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        #gantt-panel {
            bottom: 120px;
            right: 20px;
            max-width: 400px;
            max-height: 400px;
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .control-section h4 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sunburst-controls label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .sunburst-controls input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .gantt-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            border-left: 4px solid;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .gantt-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .gantt-item.requirement { border-left-color: #3B82F6; }
        .gantt-item.deliverable { border-left-color: #10B981; }
        .gantt-item.meeting { border-left-color: #F59E0B; }
        .gantt-item.deadline { border-left-color: #EF4444; }
        .gantt-item.decision { border-left-color: #8B5CF6; }
        .gantt-item.issue { border-left-color: #F97316; }

        .gantt-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .gantt-meta {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
        }

        .timeline-slider {
            width: 400px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            appearance: none;
        }

        .timeline-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(76, 175, 80, 0.5);
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 10px rgba(76, 175, 80, 0.5);
        }

        .control-button {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            font-size: 12px;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .control-button.secondary {
            background: linear-gradient(135deg, #6B7280, #4B5563);
            box-shadow: 0 4px 15px rgba(107, 114, 128, 0.3);
        }

        .control-button.active {
            background: linear-gradient(135deg, #FF6B6B, #EE5A52);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .info-item {
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-label {
            font-size: 12px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            font-size: 16px;
            font-weight: 600;
            margin-top: 3px;
            color: #4CAF50;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 200px;
        }

        .legend h4 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }

        .color-box {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }

        .legend-category {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 10px 0 5px 0;
            opacity: 0.7;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 5px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden { 
            display: none; 
        }

        .error {
            color: #ff6b6b;
            padding: 10px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 8px;
            margin: 10px 0;
        }

        .z-axis-indicator {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 150px;
        }

        .axis-label {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }

        .axis-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 8px;
        }

        /* Hover details panel */
        .details-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 300px;
            z-index: 1000;
        }

        .details-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 8px;
            color: #4CAF50;
        }

        .details-content {
            font-size: 12px;
            line-height: 1.4;
        }

        .details-content .label {
            color: rgba(255, 255, 255, 0.7);
        }

        .details-content .value {
            color: white;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="threejs-container"></div>
        
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div>Loading unified timeline data...</div>
        </div>

        <div id="control-panel" class="panel hidden">
            <h3 style="margin-bottom: 15px; color: #4CAF50;">üéõÔ∏è Controls</h3>
            <!-- Database File Controls -->
            <div class="control-section">
                <h4>Data Source</h4>
                <div style="margin-bottom: 10px; font-size: 13px;">
                    <span>Current file: </span><span id="current-db-file" style="font-weight: 600; color: #4CAF50;">unified_timeline.json</span>
                </div>
                <input type="file" id="db-file-input" accept=".json" style="margin-bottom: 10px; color: white; background: rgba(255,255,255,0.05); border-radius: 6px; padding: 6px; border: 1px solid rgba(255,255,255,0.1);" />
                <div id="db-file-error" style="color: #ff6b6b; font-size: 12px; display: none;"></div>
            </div>
            <!-- Timeline Controls -->
            <div class="control-section">
                <h4>Timeline</h4>
                <div class="info-item">
                    <div class="info-label">Current Event</div>
                    <div class="info-value" id="current-event">1 of 1</div>
                </div>
                <div style="margin: 10px 0;">
                    <input type="range" id="timeline-slider" class="timeline-slider" 
                           min="0" max="0" value="0" step="1">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="control-button" id="play-btn">‚ñ∂ Play</button>
                    <button class="control-button" id="pause-btn">‚è∏ Pause</button>
                    <button class="control-button" id="reset-btn">‚èÆ Reset</button>
                    <button class="control-button" id="jump-to-filescan-btn">üìÅ File Scans</button>
                </div>
            </div>

            <!-- Sunburst Controls -->
            <div class="control-section">
                <h4>Sunburst</h4>
                <label>Min Angle (deg):
                    <input type="range" id="min-angle-slider" min="1" max="50" value="2">
                    <span id="min-angle-value">2</span>
                </label>
                <label>Ring Thickness:
                    <input type="range" id="ring-thickness-slider" min="2" max="20" value="6">
                    <span id="ring-thickness-value">6</span>
                </label>
            </div>

            <!-- View Controls -->
            <div class="control-section">
                <h4>View</h4>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <button id="toggle-sunburst" class="control-button">Hide Sunburst</button>
                    <button id="toggle-gantt" class="control-button">Hide Gantt</button>
                    <button id="toggle-connections" class="control-button">Hide Connections</button>
                    <button id="reset-camera" class="control-button secondary">Reset Camera</button>
                </div>
            </div>

            <!-- Generation Controls -->
            <div class="control-section">
                <h4>Generate Timeline</h4>
                <p style="font-size: 12px; opacity: 0.7; margin-bottom: 10px;">
                    Enter local paths to your project folders to generate a command. Run the command in your terminal, then load the generated `unified_timeline.json` file above.
                </p>
                <label for="scan-dir-input" style="font-size: 12px; margin-bottom: 4px; display: block;">Project Folder Path:</label>
                <input type="text" id="scan-dir-input" placeholder="/path/to/project_root" style="width: 100%; padding: 5px; margin-bottom: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: white;">
                
                <label for="email-dir-input" style="font-size: 12px; margin-bottom: 4px; display: block;">Email Folder Path:</label>
                <input type="text" id="email-dir-input" placeholder="/path/to/emails" style="width: 100%; padding: 5px; margin-bottom: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: white;">

                <label for="docs-dir-input" style="font-size: 12px; margin-bottom: 4px; display: block;">Documents Folder Path:</label>
                <input type="text" id="docs-dir-input" placeholder="/path/to/documents" style="width: 100%; padding: 5px; margin-bottom: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: white;">

                <button id="generate-cmd-btn" class="control-button">Generate Command</button>
                
                <textarea id="generated-cmd-output" rows="4" style="width: 100%; margin-top: 15px; background: #0f1419; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #4CAF50; font-family: monospace; font-size: 11px; display: none; padding: 8px;"></textarea>
            </div>

            <!-- Milestone Color Controls -->
            <div class="control-section">
                <h4>Milestone Bar Colors</h4>
                <label for="milestone-select" style="font-size: 12px; margin-bottom: 4px; display: block;">Select Milestone:</label>
                <select id="milestone-select" style="width: 100%; margin-bottom: 8px;"></select>
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <label for="intended-color-picker" style="font-size: 12px;">Intended (Outline):</label>
                    <input type="color" id="intended-color-picker" value="#ff00ff">
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="actual-color-picker" style="font-size: 12px;">Actual (Solid):</label>
                    <input type="color" id="actual-color-picker" value="#ff00ff">
                </div>
            </div>
        </div>

        <div id="info-panel" class="panel hidden">
            <h3 style="margin-bottom: 15px; color: #4CAF50;">üìä Timeline Info</h3>
            <div class="info-item">
                <div class="info-label">Current Date</div>
                <div class="info-value" id="current-date">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Event Type</div>
                <div class="info-value" id="event-type">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Total Files</div>
                <div class="info-value" id="total-files">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Active Milestones</div>
                <div class="info-value" id="active-milestones">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Correlations</div>
                <div class="info-value" id="correlations-count">-</div>
            </div>

            <div id="hover-info" style="margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
                <p style="opacity: 0.6; font-size: 12px;"><em>Hover over elements for details</em></p>
            </div>
        </div>

        <div id="gantt-panel" class="panel hidden">
            <h3 style="margin-bottom: 15px; color: #4CAF50;">üìÖ Milestones</h3>
            <div id="gantt-list"></div>
        </div>

        <div class="legend hidden" id="legend">
            <h4>File Types</h4>
            <div id="legend-content"></div>
        </div>

        <div class="z-axis-indicator hidden" id="z-axis-indicator">
            <h4 style="margin-bottom: 10px; color: #4CAF50;">Inspector View</h4>
            <div class="axis-label">
                <div class="axis-color" style="background: #4CAF50;"></div>
                <span>File Scans</span>
            </div>
            <div class="axis-label">
                <div class="axis-color" style="background: #3B82F6;"></div>
                <span>Milestones</span>
            </div>
            <div style="margin-top: 10px; font-size: 11px; opacity: 0.6;">
                Camera follows timeline<br>
                Vertical inspection<br>
                Focus on current event
            </div>
        </div>

        <div class="details-panel" id="details-panel">
            <div class="details-title" id="details-title">Hover for details</div>
            <div class="details-content" id="details-content"></div>
        </div>

        <!-- Add this below the main timeline controls panel -->
        <div id="file-scan-slider-container" class="panel" style="position:absolute; left:50%; transform:translateX(-50%); bottom:70px; min-width:220px; max-width:350px; z-index:201; background:rgba(0,0,0,0.7); display:none;">
          <label style="color:#3B82F6; font-size:13px;">Jump to File Scan:
            <input type="range" id="fileScanSlider" min="0" max="0" value="0" step="1" style="width:200px;">
            <span id="fileScanSliderValue">1</span>
          </label>
        </div>
    </div>

    <script>
        class UnifiedTimelineVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.data = null;
                this.currentEventIndex = 0;
                this.isPlaying = false;
                this.playInterval = null;
                this.currentDbFile = 'unified_timeline.json';
                this.userLoadedFile = false;
                this.userCameraPosition = null;
                this.lastUserMove = 0;
                
                // Scene groups
                this.sunburstGroup = new THREE.Group();
                // this.sunburstGroup.rotation.y = 0;
                this.ganttGroup = new THREE.Group();
                this.connectionGroup = new THREE.Group();
                
                // View settings
                this.showSunburst = true;
                this.showGantt = true;
                this.showConnections = true;
                
                // Sunburst parameters
                this.minAngleDeg = 2;
                this.ringThickness = 6;
                this.zSpacing = 20;
                
                // Interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.hoveredObject = null;
                
                // Color mappings
                this.fileColors = {
                    'text/javascript': 0xf7df1e,
                    'application/javascript': 0xf7df1e,
                    'text/x-python': 0x3776ab,
                    'text/html': 0xe34c26,
                    'text/css': 0x1572b6,
                    'application/json': 0x000000,
                    'text/markdown': 0x083fa1,
                    'application/pdf': 0xff0000,
                    'text/plain': 0x9e9e9e,
                    'text/csv': 0x2ecc71,
                    'application/octet-stream': 0x95a5a6,
                    'folder': 0x4CAF50,
                    'default': 0x9e9e9e
                };
                
                this.milestoneColors = {
                    'requirement': 0x3B82F6,
                    'deliverable': 0x10B981,
                    'meeting': 0xF59E0B,
                    'deadline': 0xEF4444,
                    'decision': 0x8B5CF6,
                    'issue': 0xF97316,
                    'default': 0x6B7280
                };
                
                // Color mapping for file types (from unified_timeline_visualizer.html)
                this.colorMap = {
                    // Programming languages
                    'text/javascript': '#f7df1e',  // JavaScript
                    'application/javascript': '#f7df1e',
                    'text/x-python': '#5c37ab',  // Python
                    'text/html': '#e34c26',  // HTML
                    'text/css': '#15b6b1',  // CSS
                    'application/json': '#000000',  // JSON
                    'text/markdown': '#083fa1',  // Markdown
                    // Documents
                    'application/pdf': '#ff0000',  // PDF
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '#217346',  // Word
                    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': '#3c6f1d',  // Excel
                    'application/vnd.ms-outlook': '#d48300',  // Outlook
                    'application/vnd.ms-outlook.msg': '#d48300',  // Outlook MSG
                    'message/rfc822': '#d48300',  // Email messages
                    // Media
                    'image/': '#ff6b6b',  // Images
                    'video/': '#9b59b6',  // Video
                    'audio/': '#3498db',  // Audio
                    // Archives
                    'application/zip': '#e67e22',  // ZIP
                    'application/x-rar-compressed': '#e67e22',  // RAR
                    'application/x-7z-compressed': '#e67e22',  // 7Z
                    'application/x-tar': '#e67e22',  // TAR
                    'application/gzip': '#e67e22',  // GZIP
                    // Other
                    'text/': '#95a5a6',  // Text files
                    'folder': '#a73a81',  // Folders
                    'default': '#bdc3c7'  // Default gray
                };
                // Initialize color cache
                this.colorCache = new Map();
                
                this.fileScanEventIndices = [];
                
                this.init();
            }

            async init() {
                this.setupScene();
                this.setupEventListeners();
                await this.loadData();
                this.createVisualization();
                this.animate();
                
                this.hideLoading();
                this.showPanels();
                this.updateLegend();
                this.fileScanEventIndices = this.data.events
                  .map((e, idx) => e.event_type === 'file_scan' ? idx : -1)
                  .filter(idx => idx !== -1);
                const fileScanSlider = document.getElementById('fileScanSlider');
                const fileScanSliderContainer = document.getElementById('file-scan-slider-container');
                const fileScanSliderValue = document.getElementById('fileScanSliderValue');
                if (this.fileScanEventIndices.length > 0) {
                  fileScanSlider.max = this.fileScanEventIndices.length - 1;
                  fileScanSlider.value = 0;
                  fileScanSliderValue.textContent = '1';
                  fileScanSliderContainer.style.display = '';
                  fileScanSlider.addEventListener('input', (e) => {
                    const idx = parseInt(e.target.value);
                    fileScanSliderValue.textContent = (idx + 1).toString();
                    // Jump to the corresponding file scan event in the main timeline
                    this.currentEventIndex = this.fileScanEventIndices[idx];
                    this.updateVisualization();
                  });
                } else {
                  fileScanSliderContainer.style.display = 'none';
                }
            }

            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                
                // Remove solid background color for lightbox effect
                // this.scene.background = new THREE.Color(0x0a0e14);

                // Camera - Inspector view that follows timeline vertically
                this.camera = new THREE.PerspectiveCamera(
                    60, 
                    window.innerWidth / window.innerHeight, 
                    1, 
                    20000
                );
                // Initial camera position - will be updated based on current event
                this.camera.position.set(2.5, 30, 80);
                this.camera.lookAt(2.5, 0, 0);

                // Renderer with enhanced settings for lightbox effect
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    preserveDrawingBuffer: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x000000, 0); // Transparent background
                document.getElementById('threejs-container').appendChild(this.renderer.domElement);

                // Enhanced lighting system for lightbox effect
                this.setupLightboxLighting();

                // Add background elements for depth
                this.createBackgroundElements();

                // Add groups to scene
                this.scene.add(this.sunburstGroup);
                this.scene.add(this.ganttGroup);
                this.scene.add(this.connectionGroup);

                // Setup orbit controls
                this.setupOrbitControls();
            }

            setupLightboxLighting() {
                // Remove existing lights
                const lightsToRemove = [];
                this.scene.children.forEach(child => {
                    if (child.isLight) {
                        lightsToRemove.push(child);
                    }
                });
                lightsToRemove.forEach(light => this.scene.remove(light));

                // Create lightbox lighting setup
                
                // 1. Subtle ambient light for base illumination
                const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
                this.scene.add(ambientLight);

                // 2. Main directional light (like a spotlight)
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainLight.position.set(50, 100, 50);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                mainLight.shadow.camera.near = 0.5;
                mainLight.shadow.camera.far = 500;
                mainLight.shadow.camera.left = -100;
                mainLight.shadow.camera.right = 100;
                mainLight.shadow.camera.top = 100;
                mainLight.shadow.camera.bottom = -100;
                this.scene.add(mainLight);

                // 3. Fill light from opposite direction
                const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.4);
                fillLight.position.set(-30, 50, -30);
                this.scene.add(fillLight);

                // 4. Rim light for edge definition
                const rimLight = new THREE.DirectionalLight(0xff6b6b, 0.3);
                rimLight.position.set(0, -50, 100);
                this.scene.add(rimLight);

                // 5. Point lights for dramatic effect
                const pointLight1 = new THREE.PointLight(0x4CAF50, 0.6, 200);
                pointLight1.position.set(-20, 30, 50);
                this.scene.add(pointLight1);

                const pointLight2 = new THREE.PointLight(0x3B82F6, 0.4, 150);
                pointLight2.position.set(30, 20, -30);
                this.scene.add(pointLight2);

                // 6. Subtle hemisphere light for environmental lighting
                const hemisphereLight = new THREE.HemisphereLight(0x4a90e2, 0x1a1a2e, 0.2);
                this.scene.add(hemisphereLight);
            }

            createBackgroundElements() {
                // Create a large ground plane for shadows and depth
                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: 0x0a0e14,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -50;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Create subtle grid lines for depth perception
                const gridHelper = new THREE.GridHelper(200, 20, 0x2a2a2a, 0x1a1a1a);
                gridHelper.position.y = -49;
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.3;
                this.scene.add(gridHelper);

                // Create distant background planes for atmospheric depth
                this.createAtmosphericBackground();
            }

            createAtmosphericBackground() {
                // Back wall
                const backWallGeometry = new THREE.PlaneGeometry(800, 400);
                const backWallMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0a0e14,
                    transparent: true,
                    opacity: 0.05,
                    side: THREE.DoubleSide
                });
                const backWall = new THREE.Mesh(backWallGeometry, backWallMaterial);
                backWall.position.z = -200;
                this.scene.add(backWall);

                // Side walls for enclosure effect
                const sideWallGeometry = new THREE.PlaneGeometry(400, 400);
                const sideWallMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0a0e14,
                    transparent: true,
                    opacity: 0.03,
                    side: THREE.DoubleSide
                });

                const leftWall = new THREE.Mesh(sideWallGeometry, sideWallMaterial);
                leftWall.position.x = -200;
                leftWall.rotation.y = Math.PI / 2;
                this.scene.add(leftWall);

                const rightWall = new THREE.Mesh(sideWallGeometry, sideWallMaterial);
                rightWall.position.x = 200;
                rightWall.rotation.y = -Math.PI / 2;
                this.scene.add(rightWall);

                // Add subtle fog for atmospheric depth
                this.scene.fog = new THREE.Fog(0x0a0e14, 100, 800);
            }

            setupOrbitControls() {
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.enableZoom = true;
                this.controls.autoRotate = false;
                this.controls.autoRotateSpeed = 0.5;
                
                // Allow some movement for inspector view while maintaining focus
                this.controls.enablePan = true; // Enable panning for user control
                this.controls.minDistance = 20; // Minimum zoom distance
                this.controls.maxDistance = 150; // Maximum zoom distance
                this.controls.minPolarAngle = Math.PI / 6; // Allow more vertical rotation
                this.controls.maxPolarAngle = Math.PI / 2; // Limit vertical rotation
                
                // Add event listener to update camera position when user manually moves camera
                this.controls.addEventListener('change', () => {
                    // Store user's manual camera position for reference
                    this.userCameraPosition = this.camera.position.clone();
                    this.lastUserMove = Date.now();
                });
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());

                // Mouse interaction
                this.renderer.domElement.addEventListener('mousemove', (event) => this.handleSunburstMouseMove(event));
                this.renderer.domElement.addEventListener('mouseleave', () => this.clearSunburstHighlight());

                // Timeline controls
                document.getElementById('timeline-slider').addEventListener('input', (e) => {
                    this.setCurrentEvent(parseInt(e.target.value));
                });

                document.getElementById('play-btn').addEventListener('click', () => this.play());
                document.getElementById('pause-btn').addEventListener('click', () => this.pause());
                document.getElementById('reset-btn').addEventListener('click', () => this.reset());
                document.getElementById('jump-to-filescan-btn').addEventListener('click', () => this.jumpToFileScan());

                // Sunburst controls
                this.setupSunburstControls();

                // View controls
                document.getElementById('toggle-sunburst').addEventListener('click', () => this.toggleSunburst());
                document.getElementById('toggle-gantt').addEventListener('click', () => this.toggleGantt());
                document.getElementById('toggle-connections').addEventListener('click', () => this.toggleConnections());
                document.getElementById('reset-camera').addEventListener('click', () => this.resetCamera());

                // Database file input
                document.getElementById('db-file-input').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadCustomDbFile(file);
                    }
                });

                // Command generator
                document.getElementById('generate-cmd-btn').addEventListener('click', () => this.generateBackendCommand());

                // Milestone color controls
                this.setupMilestoneColorControls();
            }

            setupSunburstControls() {
                const minAngleSlider = document.getElementById('min-angle-slider');
                const minAngleValue = document.getElementById('min-angle-value');
                minAngleSlider.addEventListener('input', (e) => {
                    this.minAngleDeg = parseInt(e.target.value);
                    minAngleValue.textContent = this.minAngleDeg;
                    this.updateVisualization();
                });

                const ringThicknessSlider = document.getElementById('ring-thickness-slider');
                const ringThicknessValue = document.getElementById('ring-thickness-value');
                ringThicknessSlider.addEventListener('input', (e) => {
                    this.ringThickness = parseInt(e.target.value);
                    ringThicknessValue.textContent = this.ringThickness;
                    this.updateVisualization();
                });
            }

            setupMilestoneColorControls() {
                this.milestoneSelect = document.getElementById('milestone-select');
                this.intendedColorPicker = document.getElementById('intended-color-picker');
                this.actualColorPicker = document.getElementById('actual-color-picker');
                // Populate dropdown
                this.updateMilestoneDropdown();
                // On milestone select, update color pickers
                this.milestoneSelect.addEventListener('change', () => this.updateColorPickers());
                // On color change, update milestone and re-render
                this.intendedColorPicker.addEventListener('input', () => this.applyColorPickers());
                this.actualColorPicker.addEventListener('input', () => this.applyColorPickers());
            }

            updateMilestoneDropdown() {
                if (!this.data || !this.data.events) return;
                const milestones = this.data.events.filter(e => e.event_type === 'milestone');
                this.milestoneSelect.innerHTML = '';
                milestones.forEach((event, idx) => {
                    const option = document.createElement('option');
                    option.value = idx;
                    option.textContent = event.metadata.title || `Milestone ${idx + 1}`;
                    this.milestoneSelect.appendChild(option);
                });
                this.updateColorPickers();
            }

            updateColorPickers() {
                if (!this.data || !this.data.events) return;
                const milestones = this.data.events.filter(e => e.event_type === 'milestone');
                const idx = parseInt(this.milestoneSelect.value, 10) || 0;
                const milestone = milestones[idx]?.metadata;
                // Set pickers to current colors or default
                this.intendedColorPicker.value = milestone?.intended_color ? this.toHexColor(milestone.intended_color) : '#ff00ff';
                this.actualColorPicker.value = milestone?.actual_color ? this.toHexColor(milestone.actual_color) : '#ff00ff';
            }

            applyColorPickers() {
                if (!this.data || !this.data.events) return;
                const milestones = this.data.events.filter(e => e.event_type === 'milestone');
                const idx = parseInt(this.milestoneSelect.value, 10) || 0;
                const milestone = milestones[idx]?.metadata;
                if (milestone) {
                    milestone.intended_color = this.intendedColorPicker.value;
                    milestone.actual_color = this.actualColorPicker.value;
                    this.updateVisualization();
                }
            }

            toHexColor(val) {
                if (typeof val === 'string' && val.startsWith('#')) return val;
                if (typeof val === 'number') return '#' + val.toString(16).padStart(6, '0');
                if (val instanceof THREE.Color) return '#' + val.getHexString();
                return '#ff00ff';
            }

            async loadData() {
                try {
                    console.log('Loading data from:', this.currentDbFile);
                    const response = await fetch(this.currentDbFile);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    this.data = await response.json();
                    // console.log('Data loaded successfully:', {
                    //     hasData: !!this.data,
                    //     hasEvents: !!(this.data && this.data.events),
                    //     eventCount: this.data && this.data.events ? this.data.events.length : 0,
                    //     eventTypes: this.data && this.data.metadata ? this.data.metadata.event_types : {},
                    //     fileScanCount: this.data && this.data.events ? this.data.events.filter(e => e.event_type === 'file_scan').length : 0
                    // });
                    document.getElementById('current-db-file').textContent = this.currentDbFile;
                    this.initializeTimeline();
                    this.updateMilestoneDropdown();
                } catch (error) {
                    console.error('Error loading data:', error);
                    this.showError(`Failed to load data: ${error.message}`);
                    // Only generate sample data if not user-initiated
                    if (!this.userLoadedFile) {
                        this.generateSampleData();
                    }
                }
            }

            async loadCustomDbFile(file) {
                try {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            this.data = JSON.parse(e.target.result);
                            this.currentDbFile = file.name;
                            this.userLoadedFile = true;
                            document.getElementById('current-db-file').textContent = file.name;
                            document.getElementById('db-file-error').style.display = 'none';
                            this.initializeTimeline();
                            this.updateMilestoneDropdown();
                        } catch (parseErr) {
                            document.getElementById('db-file-error').textContent = 'Invalid JSON file.';
                            document.getElementById('db-file-error').style.display = 'block';
                        }
                    };
                    reader.readAsText(file);
                } catch (error) {
                    document.getElementById('db-file-error').textContent = 'Failed to load file.';
                    document.getElementById('db-file-error').style.display = 'block';
                }
            }

            generateBackendCommand() {
                const scanDir = document.getElementById('scan-dir-input').value.trim();
                const emailDir = document.getElementById('email-dir-input').value.trim();
                const docsDir = document.getElementById('docs-dir-input').value.trim();
                const outputArea = document.getElementById('generated-cmd-output');

                let command = 'python unified_backend.py';
                if (scanDir) {
                    command += ` --scan-dir "${scanDir}"`;
                }
                if (emailDir) {
                    command += ` --email-dir "${emailDir}"`;
                }
                if (docsDir) {
                    command += ` --docs-dir "${docsDir}"`;
                }
                command += ' --correlate --output unified_timeline.json';

                if (!scanDir && !emailDir && !docsDir) {
                    outputArea.value = 'Please provide at least one directory path.';
                } else {
                    outputArea.value = command;
                }
                
                outputArea.style.display = 'block';
            }


            initializeTimeline() {
                // console.log('Initializing timeline with data:', {
                //     hasData: !!this.data,
                //     hasEvents: !!(this.data && this.data.events),
                //     eventCount: this.data && this.data.events ? this.data.events.length : 0
                // });
                
                if (!this.data || !this.data.events || this.data.events.length === 0) {
                    this.showError('No timeline data available');
                    return;
                }

                const slider = document.getElementById('timeline-slider');
                slider.max = this.data.events.length - 1;
                
                // Start at the end to show all events including file_scan events
                this.currentEventIndex = this.data.events.length - 1;
                slider.value = this.currentEventIndex;
                
                console.log('Timeline initialized, calling updateVisualization');
                this.updateVisualization();
                this.updateInfo();
                this.updateGanttChart();
                this.updateLegend();
                this.updateCameraPosition();
            }

            createVisualization() {
                this.updateVisualization();
            }

            updateVisualization() {
                // Clear existing visualization
                this.clearGroups();

                if (!this.data || !this.data.events) {
                    console.log('No data or events available');
                    return;
                }

                // Show events up to current index
                const eventsToShow = this.data.events.slice(0, this.currentEventIndex + 1);
                // console.log('updateVisualization called:', {
                //     totalEvents: this.data.events.length,
                //     currentEventIndex: this.currentEventIndex,
                //     eventsToShow: eventsToShow.length,
                //     showSunburst: this.showSunburst,
                //     showGantt: this.showGantt,
                //     showConnections: this.showConnections
                // });
                
                if (this.showSunburst) {
                    this.createSunburstVisualization(eventsToShow);
                }
                
                if (this.showGantt) {
                    this.createGanttVisualization(eventsToShow);
                }

                if (this.showConnections) {
                    this.createConnections(eventsToShow);
                }

                this.updateInfo();
                document.getElementById('current-event').textContent = 
                    `${this.currentEventIndex + 1} of ${this.data.events.length}`;
            }

            clearGroups() {
                [this.sunburstGroup, this.ganttGroup, this.connectionGroup].forEach(group => {
                    while (group.children.length > 0) {
                        group.remove(group.children[0]);
                    }
                });
            }

            createSunburstVisualization(events) {
                console.log('Creating sunburst visualization for events:', events.length);
                const fileScanEvents = events.filter(e => e.event_type === 'file_scan');
                console.log('File scan events found:', fileScanEvents.length);
                
                // In createSunburstVisualization, compute minTime, maxTime, minY, maxY as in Gantt
                const scanTimes = fileScanEvents.map(e => e.timestamp);
                const minTime = Math.min(...scanTimes);
                const maxTime = Math.max(...scanTimes);
                const minY = 0, maxY = 100;
                
                events.forEach((event, index) => {
                    console.log(`Processing event ${index}:`, {
                        eventType: event.event_type,
                        hasTreeStructure: !!(event.metadata && event.metadata.tree_structure),
                        treeStructureKeys: event.metadata && event.metadata.tree_structure ? Object.keys(event.metadata.tree_structure) : []
                    });
                    
                    if (event.event_type === 'file_scan' && event.metadata && event.metadata.tree_structure) {
                        // Position all events at the same Z position (centered) - timeline scrolls by
                        const zPosition = 0; // Fixed center position
                        console.log(`Creating sunburst for file_scan event at index ${index}, zPosition ${zPosition}`);
                        this.createSunburstAtPosition(event.metadata.tree_structure, zPosition, index, this.timestampToY(event.timestamp, minTime, maxTime, minY, maxY));
                        this.createTextLabel(new Date(event.timestamp * 1000).toLocaleDateString(), zPosition, 'file_scan');
                    }
                });
            }

            createSunburstAtPosition(treeData, zPosition, eventIndex, yPosition) {
                const group = this.createSunburst(treeData, eventIndex, 0); // zOffset = 0
                group.position.y = yPosition;
                group.rotation.x = Math.PI / 2;
                this.sunburstGroup.add(group);
            }

            // Advanced sunburst logic
            createSunburst(treeData, eventIndex, zOffset) {
                const group = new THREE.Group();
                const minAngleDeg = this.minAngleDeg || 2;
                const minAngleRad = minAngleDeg * Math.PI / 180;
                const ringThickness = this.ringThickness;
                const ringGap = 2;

                // Color cache for this sunburst
                this.colorCache = this.colorCache || new Map();
                this.segmentMeshes = new Map();
                this.connectionLinesByChild = new Map();
                this.connectionLines = [];

                // Helper to get the center point of a segment at a given radius and angle
                const getSegmentCenter = (innerRadius, outerRadius, startAngle, endAngle, z) => {
                    const angle = (startAngle + endAngle) / 2;
                    const radius = (innerRadius + outerRadius) / 2;
                    return new THREE.Vector3(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        z
                    );
                };

                const createRingSegment = (node, innerRadius, outerRadius, startAngle, endAngle, depth, colorOverride = null) => {
                    const segments = 64;
                    const geometry = new THREE.RingGeometry(
                        innerRadius,
                        outerRadius,
                        segments,
                        1,
                        startAngle,
                        endAngle - startAngle
                    );
                    let baseColor = colorOverride || this.getColorForNode(node);
                    if (typeof baseColor === 'string' && !baseColor.startsWith('#')) {
                        baseColor = `#${baseColor}`;
                    }
                    const color = new THREE.Color(baseColor);
                    const material = new THREE.MeshLambertMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.8,
                        side: THREE.DoubleSide
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.z = depth * 2; // Separate each ring in Z within a sunburst
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    mesh.userData = { 
                        node, 
                        eventIndex, 
                        depth, 
                        innerRadius, 
                        outerRadius, 
                        startAngle, 
                        endAngle,
                        baseColor: baseColor,
                        originalColor: baseColor
                    };
                    return mesh;
                };

                let segmentCount = 0;
                const buildSunburst = (node, innerRadius, outerRadius, startAngle, endAngle, depth = 0, siblingIndex = 0, siblingCount = 1, parentInfo = null, parentNode = null) => {
                    // Debug log for node properties
                    console.log(`[SUNBURST-DEBUG] buildSunburst: name=${node.name}, type=${node.type}, size=${node.size}, value=${node.value}, children=${node.children ? node.children.length : 0}, depth=${depth}`);
                    node.parent = parentNode;
                    // [SUNBURST-DEBUG] Log node info and recursion
                    const children = node.children || [];
                    console.log(`[SUNBURST-DEBUG] buildSunburst: name='${node.name}', type='${node.type}', children=${children.length}, depth=${depth}, innerRadius=${innerRadius}, outerRadius=${outerRadius}, startAngle=${startAngle}, endAngle=${endAngle}`);
                    let baseColor = this.getColorForNode ? this.getColorForNode(node) : '#9e9e9e';
                    if (node.type === 'file' && siblingCount > 1) {
                        const hsl = {};
                        new THREE.Color(baseColor).getHSL(hsl);
                        hsl.l = 0.45 + 0.2 * (siblingIndex / (siblingCount - 1));
                        const color = new THREE.Color();
                        color.setHSL(hsl.h, hsl.s, hsl.l);
                        baseColor = `#${color.getHexString()}`;
                    }
                    const mesh = createRingSegment(node, innerRadius, outerRadius, startAngle, endAngle, depth, baseColor);
                    group.add(mesh);
                    segmentCount++;
                    this.segmentMeshes.set(node, mesh);
                    // Draw connection line if parentInfo is provided
                    if (parentInfo) {
                        const parentCenter = getSegmentCenter(
                            parentInfo.innerRadius, parentInfo.outerRadius, parentInfo.startAngle, parentInfo.endAngle, (depth - 1) * 2 + zOffset
                        );
                        const childCenter = getSegmentCenter(
                            innerRadius, outerRadius, startAngle, endAngle, depth * 2 + zOffset
                        );
                        const midRadius = (parentInfo.outerRadius + innerRadius) / 2 + ringGap * 0.5;
                        const midAngle = (parentInfo.endAngle + startAngle) / 2;
                        const controlPoint = new THREE.Vector3(
                            Math.cos(midAngle) * midRadius,
                            Math.sin(midAngle) * midRadius,
                            (parentCenter.z + childCenter.z) / 2
                        );
                        const curve = new THREE.QuadraticBezierCurve3(parentCenter, controlPoint, childCenter);
                        const points = curve.getPoints(32);
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true }));
                        group.add(line);
                        line.userData = {
                            type: 'connection',
                            parentNode: parentInfo.node,
                            childNode: node
                        };
                        this.connectionLines.push(line);
                        this.connectionLinesByChild.set(node, line);
                    }
                    // Process children
                    if (children.length > 0) {
                        const n = children.length;
                        const totalSize = children.reduce((sum, child) => sum + (child.size || 1), 0);
                        const totalMinAngle = n * minAngleRad;
                        const availableAngle = Math.max(0, (endAngle - startAngle) - totalMinAngle);
                        let currentAngle = startAngle;
                        children.forEach((child, i) => {
                            const childSize = child.size || 1;
                            const angleSpan = minAngleRad + (availableAngle * (childSize / totalSize));
                            const childEndAngle = currentAngle + angleSpan;
                            buildSunburst(
                                child,
                                outerRadius + ringGap,
                                outerRadius + ringGap + ringThickness,
                                currentAngle,
                                childEndAngle,
                                depth + 1,
                                i,
                                n,
                                { innerRadius, outerRadius, startAngle, endAngle, node },
                                node
                            );
                            currentAngle = childEndAngle;
                        });
                    }
                };
                // Start at radius 5 for unified visualizer
                buildSunburst(treeData, 2, 2 + ringThickness, 0, Math.PI * 2);
                console.log(`[SUNBURST-DEBUG] Total segments created and added: ${segmentCount}`);
                return group;
            }

            // Map timestamp to Y position (linear between min/max)
            timestampToY(timestamp, minTime, maxTime, minY, maxY) {
                if (maxTime === minTime) return minY;
                const t = (timestamp - minTime) / (maxTime - minTime);
                return minY + t * (maxY - minY);
            }

            createGanttVisualization(events) {
                const milestoneEvents = events.filter(e => e.event_type === 'milestone');
                if (milestoneEvents.length === 0) return;
                // Timeline axis parameters
                const axisX = 0, axisZ = 0;
                const axisColor = 0xff00ff; // bright purple
                const axisWidth = 0.3;
                const minY = 0, maxY = 100; // Y range for timeline
                // Get min/max times
                const times = milestoneEvents.map(e => e.metadata.start_time || e.timestamp);
                const endTimes = milestoneEvents.map(e => (e.metadata.end_time || (e.metadata.start_time || e.timestamp) + (e.metadata.duration || 86400)));
                const minTime = Math.min(...times);
                const maxTime = Math.max(...endTimes);
                // Log Y location for each file scan event
                events.forEach((event, idx) => {
                    if (event.event_type === 'file_scan') {
                        const y = this.timestampToY(event.timestamp, minTime, maxTime, minY, maxY);
                        console.log(`[DEBUG] File scan event at timestamp ${event.timestamp} mapped to Y=${y}`);
                    }
                });
                // Draw vertical axis
                const axisGeom = new THREE.CylinderGeometry(axisWidth, axisWidth, maxY - minY + 10, 32);
                const axisMat = new THREE.MeshBasicMaterial({ color: axisColor });
                const axisMesh = new THREE.Mesh(axisGeom, axisMat);
                axisMesh.position.set(axisX, (minY + maxY) / 2, axisZ);
                this.ganttGroup.add(axisMesh);
                // Draw dashed horizontal reference line at first milestone Y
                const firstY = this.timestampToY(times[0], minTime, maxTime, minY, maxY);
                const dashMat = new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 2, gapSize: 2 });
                const dashGeom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-20, firstY, axisZ),
                    new THREE.Vector3(20, firstY, axisZ)
                ]);
                const dashLine = new THREE.Line(dashGeom, dashMat);
                dashLine.computeLineDistances();
                this.ganttGroup.add(dashLine);
                // For each milestone, draw tick, bar, and label
                milestoneEvents.forEach((event, index) => {
                    const milestone = event.metadata;
                    const startTime = milestone.start_time || event.timestamp;
                    const duration = milestone.duration || (milestone.end_time ? (milestone.end_time - startTime) : 86400);
                    const endTime = milestone.end_time || (startTime + duration);
                    const intendedEnd = milestone.intended_end_time || endTime;
                    const actualEnd = milestone.actual_end_time || endTime;
                    const intendedDuration = intendedEnd - startTime;
                    const actualDuration = actualEnd - startTime;
                    const startY = this.timestampToY(startTime, minTime, maxTime, minY, maxY);
                    const intendedBarHeight = this.timestampToY(intendedEnd, minTime, maxTime, minY, maxY) - startY;
                    const actualBarHeight = this.timestampToY(actualEnd, minTime, maxTime, minY, maxY) - startY;
                    // Colors: allow manual override
                    let intendedColor = milestone.intended_color || 0xff00ff;
                    let actualColor = milestone.actual_color || 0xff00ff;
                    // Accept CSS color strings
                    if (typeof intendedColor === 'string') intendedColor = new THREE.Color(intendedColor);
                    if (typeof actualColor === 'string') actualColor = new THREE.Color(actualColor);
                    // Draw tick/marker at startY
                    const tickGeom = new THREE.CylinderGeometry(0.5, 0.5, 2, 16);
                    const tickMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                    const tick = new THREE.Mesh(tickGeom, tickMat);
                    tick.position.set(axisX, startY, axisZ);
                    this.ganttGroup.add(tick);
                    // Draw horizontal dashed line from axis to bar
                    const barOffsetX = 10;
                    const dashGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(axisX, startY, axisZ),
                        new THREE.Vector3(axisX + barOffsetX, startY, axisZ)
                    ]);
                    const dashLine = new THREE.Line(dashGeom, dashMat);
                    dashLine.computeLineDistances();
                    this.ganttGroup.add(dashLine);
                    // Draw intended duration outline bar (vertical, at end of dashed line)
                    const intendedBarGeom = new THREE.BoxGeometry(2, Math.abs(intendedBarHeight), 2);
                    const intendedBarEdges = new THREE.EdgesGeometry(intendedBarGeom);
                    const intendedBarLine = new THREE.LineSegments(
                        intendedBarEdges,
                        new THREE.LineBasicMaterial({ color: intendedColor, linewidth: 2 })
                    );
                    intendedBarLine.position.set(axisX + barOffsetX, startY + intendedBarHeight / 2, axisZ);
                    this.ganttGroup.add(intendedBarLine);
                    // Draw actual duration solid bar (vertical, inside outline)
                    const actualBarGeom = new THREE.BoxGeometry(1.2, Math.abs(actualBarHeight), 1.2);
                    const actualBarMat = new THREE.MeshLambertMaterial({ color: actualColor });
                    const actualBar = new THREE.Mesh(actualBarGeom, actualBarMat);
                    actualBar.position.set(axisX + barOffsetX, startY + actualBarHeight / 2, axisZ);
                    this.ganttGroup.add(actualBar);
                    // Optionally, draw dashed line at intended endY
                    const endDashGeom = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(axisX, startY + intendedBarHeight, axisZ),
                        new THREE.Vector3(axisX + barOffsetX, startY + intendedBarHeight, axisZ)
                    ]);
                    const endDashLine = new THREE.Line(endDashGeom, dashMat);
                    endDashLine.computeLineDistances();
                    this.ganttGroup.add(endDashLine);
                    // Label at top of intended bar
                    this.createTextLabel(milestone.title, axisX + barOffsetX + 4, startY + intendedBarHeight + 2, axisZ);
                });
            }

            createTextLabel(text, x, y, z) {
                // Ensure text is a string
                if (typeof text !== 'string') {
                    if (typeof text === 'number') {
                        // Assume timestamp, format as date string
                        text = new Date(text * 1000).toLocaleDateString();
                    } else {
                        text = String(text);
                    }
                }
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.font = 'bold 12px Arial';
                context.fillStyle = '#ffffff';
                context.fillText(text.substring(0, 20), 10, 30);
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                const geometry = new THREE.PlaneGeometry(12, 3);
                const textMesh = new THREE.Mesh(geometry, material);
                textMesh.position.set(x, y, z);
                textMesh.lookAt(this.camera.position);
                this.ganttGroup.add(textMesh);
            }

            createTimeLabel(timestamp, z, eventType) {
                const date = new Date(timestamp * 1000);
                const dateStr = date.toLocaleDateString();
                
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 32;
                const context = canvas.getContext('2d');
                
                context.fillStyle = eventType === 'file_scan' ? '#4CAF50' : '#3B82F6';
                context.font = '12px Arial';
                context.fillText(dateStr, 10, 20);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const geometry = new THREE.PlaneGeometry(8, 2);
                const label = new THREE.Mesh(geometry, material);
                
                // Position label to align with sunburst
                label.position.set(-15, 0, z); // Moved to align with sunburst at X=0
                label.lookAt(this.camera.position);
                
                this.sunburstGroup.add(label);
            }

            createConnections(events) {
                if (!this.data.correlations) return;

                this.data.correlations.forEach(correlation => {
                    const fileEvent = events.find(e => e.event_id === correlation.file_event_id);
                    const milestoneEvent = events.find(e => e.event_id === correlation.milestone_event_id);
                    
                    if (fileEvent && milestoneEvent) {
                        // All events are at the same Z position now
                        const zPosition = 0; // Fixed center position
                        
                        this.createConnectionLine(
                            new THREE.Vector3(0, 0, zPosition), // Sunburst position
                            new THREE.Vector3(5, 0, zPosition), // Milestone position
                            correlation.correlation_strength
                        );
                    }
                });
            }

            createConnectionLine(startPos, endPos, strength) {
                const geometry = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                const material = new THREE.LineBasicMaterial({
                    color: 0xF59E0B,
                    transparent: true,
                    opacity: strength * 0.8
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { type: 'connection', strength: strength };
                
                this.connectionGroup.add(line);
            }

            updateGanttChart() {
                const ganttList = document.getElementById('gantt-list');
                ganttList.innerHTML = '';

                if (!this.data || !this.data.events) return;

                const milestoneEvents = this.data.events
                    .filter(e => e.event_type === 'milestone')
                    .slice(0, this.currentEventIndex + 1);

                milestoneEvents.forEach(event => {
                    const milestone = event.metadata;
                    const item = document.createElement('div');
                    item.className = `gantt-item ${milestone.category}`;
                    
                    item.innerHTML = `
                        <div class="gantt-title">${milestone.title}</div>
                        <div class="gantt-meta">
                            <span>${milestone.priority.toUpperCase()}</span>
                            <span>${milestone.confidence.toFixed(1)}</span>
                        </div>
                    `;
                    
                    item.addEventListener('click', () => {
                        this.focusOnMilestone(event);
                    });
                    
                    ganttList.appendChild(item);
                });
            }

            updateInfo() {
                if (!this.data || !this.data.events) return;

                const currentEvent = this.data.events[this.currentEventIndex];
                
                document.getElementById('current-date').textContent = 
                    new Date(currentEvent.timestamp * 1000).toLocaleDateString();
                document.getElementById('event-type').textContent = 
                    currentEvent.event_type.replace('_', ' ').toUpperCase();
                
                if (currentEvent.event_type === 'file_scan') {
                    document.getElementById('total-files').textContent = 
                        currentEvent.metadata.file_count || 0;
                } else {
                    // Calculate cumulative files from previous file scans
                    let totalFiles = 0;
                    for (let i = 0; i <= this.currentEventIndex; i++) {
                        const event = this.data.events[i];
                        if (event.event_type === 'file_scan') {
                            totalFiles = event.metadata.file_count || 0;
                        }
                    }
                    document.getElementById('total-files').textContent = totalFiles;
                }

                const activeMilestones = this.data.events
                    .slice(0, this.currentEventIndex + 1)
                    .filter(e => e.event_type === 'milestone').length;
                document.getElementById('active-milestones').textContent = activeMilestones;

                document.getElementById('correlations-count').textContent = 
                    this.data.correlations ? this.data.correlations.length : 0;
            }

            updateLegend() {
                const legendContent = document.getElementById('legend-content');
                if (!legendContent) return;
                const categories = {
                    'Programming': ['text/javascript', 'text/x-python', 'text/html', 'text/css', 'application/json', 'text/markdown'],
                    'Documents': ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 
                                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-outlook'],
                    'Media': ['image/', 'video/', 'audio/'],
                    'Other': ['text/', 'folder', 'default']
                };

                let html = '';
                for (const [category, types] of Object.entries(categories)) {
                    html += `<div class="legend-category">${category}</div>`;
                    types.forEach(type => {
                        const color = this.colorMap[type];
                        let label = type.split('/').pop().replace('application/vnd.', '').replace('openxmlformats-officedocument.', '')
                            .replace('wordprocessingml.document', 'Word')
                            .replace('spreadsheetml.sheet', 'Excel')
                            .replace('ms-outlook', 'Outlook')
                            .replace('x-python', 'Python')
                            .replace('javascript', 'JavaScript')
                            .replace('html', 'HTML')
                            .replace('css', 'CSS')
                            .replace('json', 'JSON')
                            .replace('markdown', 'Markdown')
                            .replace('pdf', 'PDF')
                            .replace('image', 'Images')
                            .replace('video', 'Video')
                            .replace('audio', 'Audio')
                            .replace('text', 'Text Files')
                            .replace('folder', 'Folders')
                            .replace('default', 'Other Files');
                        html += `
                            <div class="legend-item">
                                <div class="color-box" style="background-color: ${color};"></div>
                                <span>${label}</span>
                            </div>
                        `;
                    });
                }
                legendContent.innerHTML = html;
            }

            handleSunburstMouseMove(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const allObjects = [
                    ...this.sunburstGroup.children,
                    ...(this.connectionLines || [])
                ];
                const intersects = this.raycaster.intersectObjects(allObjects, true);

                // Revert all previously highlighted objects
                if (!this.highlightedObjects) this.highlightedObjects = new Set();
                this.highlightedObjects.forEach(obj => {
                    // Revert segments
                    if (obj.isMesh) {
                        let originalColor = obj.userData && obj.userData.originalColor;
                        if (typeof originalColor === 'string' && !originalColor.startsWith('#')) {
                            originalColor = `#${originalColor}`;
                        }
                        if (originalColor) {
                            obj.material.color.set(originalColor);
                        }
                        obj.material.opacity = 0.8;
                    }
                    // Revert lines
                    if (obj.isLine) {
                        obj.material.color.set(0xffffff);
                        obj.material.opacity = 0.3;
                    }
                });
                this.highlightedObjects.clear();

                if (intersects.length > 0) {
                    const intersected = intersects[0].object;
                    // Highlight path if hovering a segment
                    if (intersected.userData && intersected.userData.node) {
                        let node = intersected.userData.node;
                        while (node) {
                            // Highlight segment
                            const mesh = this.segmentMeshes && this.segmentMeshes.get(node);
                            if (mesh) {
                                // Store current color if not already stored
                                if (!mesh.userData.originalColor) {
                                    let currentColor = mesh.material.color.getHexString();
                                    if (typeof currentColor === 'string' && !currentColor.startsWith('#')) {
                                        currentColor = `#${currentColor}`;
                                    }
                                    mesh.userData.originalColor = currentColor;
                                }
                                mesh.material.color.set('#00ff66');
                                mesh.material.opacity = 1.0;
                                this.highlightedObjects.add(mesh);
                            }
                            // Highlight connection line from parent to node
                            const line = this.connectionLinesByChild && this.connectionLinesByChild.get(node);
                            if (line) {
                                line.material.color.set('#00ff66');
                                line.material.opacity = 1.0;
                                this.highlightedObjects.add(line);
                            }
                            node = node.parent;
                        }
                        this.showSunburstDetailsPanel(intersected.userData.node, event.clientX, event.clientY);
                        this.hoveredObject = intersected;
                    } else if (intersected.userData && intersected.userData.type === 'connection') {
                        // If hovering a connection line, highlight it and its child/parent segments
                        const line = intersected;
                        line.material.color.set('#00ff66');
                        line.material.opacity = 1.0;
                        this.highlightedObjects.add(line);
                        // Highlight child and parent segments
                        const childMesh = this.segmentMeshes && this.segmentMeshes.get(line.userData.childNode);
                        if (childMesh) {
                            if (!childMesh.userData.originalColor) {
                                let currentColor = childMesh.material.color.getHexString();
                                if (typeof currentColor === 'string' && !currentColor.startsWith('#')) {
                                    currentColor = `#${currentColor}`;
                                }
                                childMesh.userData.originalColor = currentColor;
                            }
                            childMesh.material.color.set('#00ff66');
                            childMesh.material.opacity = 1.0;
                            this.highlightedObjects.add(childMesh);
                        }
                        const parentMesh = this.segmentMeshes && this.segmentMeshes.get(line.userData.parentNode);
                        if (parentMesh) {
                            if (!parentMesh.userData.originalColor) {
                                let currentColor = parentMesh.material.color.getHexString();
                                if (typeof currentColor === 'string' && !currentColor.startsWith('#')) {
                                    currentColor = `#${currentColor}`;
                                }
                                parentMesh.userData.originalColor = currentColor;
                            }
                            parentMesh.material.color.set('#00ff66');
                            parentMesh.material.opacity = 1.0;
                            this.highlightedObjects.add(parentMesh);
                        }
                        this.showSunburstDetailsPanel(null);
                    }
                } else {
                    this.showSunburstDetailsPanel(null);
                    this.hoveredObject = null;
                }
            }

            clearSunburstHighlight() {
                if (!this.highlightedObjects) return;
                this.highlightedObjects.forEach(obj => {
                    if (obj.isMesh) {
                        let originalColor = obj.userData && obj.userData.originalColor;
                        if (typeof originalColor === 'string' && !originalColor.startsWith('#')) {
                            originalColor = `#${originalColor}`;
                        }
                        if (originalColor) {
                            obj.material.color.set(originalColor);
                        }
                        obj.material.opacity = 0.8;
                    }
                    if (obj.isLine) {
                        obj.material.color.set(0xffffff);
                        obj.material.opacity = 0.3;
                    }
                });
                this.highlightedObjects.clear();
                this.showSunburstDetailsPanel(null);
            }

            showSunburstDetailsPanel(node, x, y) {
                // Use the hover-info panel for details
                const panel = document.getElementById('details-panel');
                const title = document.getElementById('details-title');
                const content = document.getElementById('details-content');
                if (!node) {
                    title.textContent = 'Hover for details';
                    content.innerHTML = '';
                    panel.style.opacity = '0';
                    return;
                }
                title.textContent = node.name || 'File/Folder';
                let html = `<div><span class='label'>Type:</span> <span class='value'>${node.type || 'file'}</span></div>`;
                if (node.size) {
                    html += `<div><span class='label'>Size:</span> <span class='value'>${this.formatBytes(node.size)}</span></div>`;
                }
                if (node.type === 'file') {
                    if (node.mime_type) html += `<div><span class='label'>MIME:</span> <span class='value'>${node.mime_type}</span></div>`;
                    if (node.file_hash) html += `<div><span class='label'>Hash:</span> <span class='value'>${node.file_hash}</span></div>`;
                } else {
                    if (node.file_count) html += `<div><span class='label'>Files:</span> <span class='value'>${node.file_count}</span></div>`;
                }
                content.innerHTML = html;
                // Position panel near mouse
                if (typeof x === 'number' && typeof y === 'number') {
                    panel.style.left = `${Math.min(x + 20, window.innerWidth - 320)}px`;
                    panel.style.top = `${Math.min(y + 20, window.innerHeight - 200)}px`;
                }
                panel.style.opacity = '1';
            }

            play() {
                if (this.isPlaying) return;
                
                this.isPlaying = true;
                document.getElementById('play-btn').classList.add('active');
                
                this.playInterval = setInterval(() => {
                    if (this.currentEventIndex < this.data.events.length - 1) {
                        this.setCurrentEvent(this.currentEventIndex + 1);
                    } else {
                        this.pause();
                    }
                }, 2000);
            }

            pause() {
                this.isPlaying = false;
                document.getElementById('play-btn').classList.remove('active');
                
                if (this.playInterval) {
                    clearInterval(this.playInterval);
                    this.playInterval = null;
                }
            }

            reset() {
                this.pause();
                this.setCurrentEvent(0);
                this.resetCamera();
            }

            setCurrentEvent(index) {
                if (!this.data || index < 0 || index >= this.data.events.length) {
                    console.log('Invalid event index:', index);
                    return;
                }
                
                console.log(`Setting current event to index ${index}:`, {
                    eventType: this.data.events[index].event_type,
                    eventId: this.data.events[index].event_id,
                    timestamp: this.data.events[index].timestamp
                });
                
                this.currentEventIndex = index;
                document.getElementById('timeline-slider').value = index;
                this.updateVisualization();
                this.updateGanttChart();
                this.updateCameraPosition();
            }

            toggleSunburst() {
                this.showSunburst = !this.showSunburst;
                const button = document.getElementById('toggle-sunburst');
                button.textContent = this.showSunburst ? 'Hide Sunburst' : 'Show Sunburst';
                this.sunburstGroup.visible = this.showSunburst;
            }

            toggleGantt() {
                this.showGantt = !this.showGantt;
                const button = document.getElementById('toggle-gantt');
                button.textContent = this.showGantt ? 'Hide Gantt' : 'Show Gantt';
                this.ganttGroup.visible = this.showGantt;
            }

            toggleConnections() {
                this.showConnections = !this.showConnections;
                const button = document.getElementById('toggle-connections');
                button.textContent = this.showConnections ? 'Hide Connections' : 'Show Connections';
                this.connectionGroup.visible = this.showConnections;
            }

            resetCamera() {
                // Inspector view - update camera position based on current event
                this.userCameraPosition = null; // Reset user camera position
                this.lastUserMove = 0; // Reset user move timestamp
                this.updateCameraPosition();
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            hideLoading() {
                document.getElementById('loading').classList.add('hidden');
            }

            showPanels() {
                document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('hidden'));
                document.getElementById('legend').classList.remove('hidden');
                document.getElementById('z-axis-indicator').classList.remove('hidden');
            }

            showError(message) {
                const loading = document.getElementById('loading');
                loading.innerHTML = `<div class="error">Error: ${message}</div>`;
                console.error('Visualizer Error:', message);
            }

            jumpToFileScan() {
                if (!this.data || !this.data.events) return;
                
                // Find the last file_scan event to show all file_scan events
                let lastFileScanIndex = -1;
                for (let i = this.data.events.length - 1; i >= 0; i--) {
                    if (this.data.events[i].event_type === 'file_scan') {
                        lastFileScanIndex = i;
                        break;
                    }
                }
                
                if (lastFileScanIndex !== -1) {
                    console.log(`Jumping to last file_scan event at index ${lastFileScanIndex}`);
                    this.setCurrentEvent(lastFileScanIndex);
                } else {
                    console.log('No file_scan events found in timeline');
                }
            }

            updateCameraPosition() {
                if (!this.data || !this.data.events || this.currentEventIndex < 0) {
                    return;
                }

                // Find all milestones and file scans up to and including the current event
                const eventsUpToCurrent = this.data.events.slice(0, this.currentEventIndex + 1);
                const milestoneEvents = eventsUpToCurrent.filter(e => e.event_type === 'milestone');
                const fileScanEvents = eventsUpToCurrent.filter(e => e.event_type === 'file_scan');

                // Find the Y position for the current event
                let targetY = 0;
                const currentEvent = this.data.events[this.currentEventIndex];
                if (currentEvent.event_type === 'milestone' && milestoneEvents.length > 0) {
                    // Center on the current milestone
                    const milestoneIndex = milestoneEvents.length - 1;
                    targetY = milestoneIndex * 12;
                } else if (currentEvent.event_type === 'file_scan' && fileScanEvents.length > 0) {
                    // Center on the current file scan
                    const fileScanIndex = fileScanEvents.length - 1;
                    targetY = fileScanIndex * 12;
                } else if (milestoneEvents.length > 0) {
                    // Center on the last milestone before current event
                    const milestoneIndex = milestoneEvents.length - 1;
                    targetY = milestoneIndex * 12;
                } else if (fileScanEvents.length > 0) {
                    // Center on the last file scan before current event
                    const fileScanIndex = fileScanEvents.length - 1;
                    targetY = fileScanIndex * 12;
                } else {
                    // No milestones or file scans yet, default to 0
                    targetY = 0;
                }

                // Set camera and controls target directly
                this.camera.position.set(2.5, targetY + 30, 80);
                this.controls.target.set(2.5, targetY, 0);
                this.camera.lookAt(this.controls.target);
                this.controls.update();
            }

            // Add to UnifiedTimelineVisualizer prototype:
            getColorForNode(node) {
                // Check cache first
                if (this.colorCache.has(node)) {
                    return this.colorCache.get(node);
                }
                let color;
                if (node.type === 'folder') {
                    color = this.colorMap['folder'];
                } else {
                    const mimeType = node.mime_type;
                    if (!mimeType) {
                        color = this.colorMap['default'];
                    } else {
                        // 1. Exact match
                        if (this.colorMap[mimeType]) {
                            color = this.colorMap[mimeType];
                        } else {
                            // 2. Check file extension for common types
                            const extension = node.name && node.name.split('.').pop().toLowerCase();
                            const extensionMap = {
                                'msg': this.colorMap['application/vnd.ms-outlook.msg'],
                                'eml': this.colorMap['message/rfc822'],
                                'zip': this.colorMap['application/zip'],
                                'rar': this.colorMap['application/x-rar-compressed'],
                                '7z': this.colorMap['application/x-7z-compressed'],
                                'tar': this.colorMap['application/x-tar'],
                                'gz': this.colorMap['application/gzip'],
                                'pdf': this.colorMap['application/pdf'],
                                'docx': this.colorMap['application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
                                'xlsx': this.colorMap['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],
                                'doc': this.colorMap['application/vnd.ms-outlook'],
                                'txt': this.colorMap['text/'],
                                'md': this.colorMap['text/markdown']
                            };
                            if (extension && extensionMap[extension]) {
                                color = extensionMap[extension];
                            } else {
                                // 3. Prefix match (e.g., image/, text/)
                                let found = false;
                                for (const [pattern, patternColor] of Object.entries(this.colorMap)) {
                                    if (pattern.endsWith('/') && mimeType.startsWith(pattern)) {
                                        color = patternColor;
                                        found = true;
                                        break;
                                    }
                                }
                                if (!found) {
                                    color = this.colorMap['default'];
                                }
                            }
                        }
                    }
                }
                // Always prefix with #
                if (typeof color === 'string' && !color.startsWith('#')) {
                    color = `#${color}`;
                }
                // HARDEN: If color is empty, null, or not a valid hex, force to #bdc3c7
                if (!color || typeof color !== 'string' || !/^#([0-9a-fA-F]{3}){1,2}$/.test(color)) {
                    console.warn('[Sunburst] Fallback to default color for node:', node, 'Got color:', color);
                    color = '#bdc3c7';
                }
                // Debug: Log every node and its color
                console.log('[Sunburst] Node color:', { name: node.name, type: node.type, mime: node.mime_type, color });
                // Cache the color
                this.colorCache.set(node, color);
                return color;
            }
        }

        // Initialize the visualizer when the page loads
        window.addEventListener('load', () => {
            new UnifiedTimelineVisualizer();
        });
    </script>
</body>
</html>