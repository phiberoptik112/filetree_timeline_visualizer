<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified File Tree & Milestone Timeline Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f1419 100%);
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #threejs-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #threejs-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 50% 50%, rgba(74, 144, 226, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: 1;
        }

        #threejs-container canvas {
            position: relative;
            z-index: 2;
        }

        .panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            z-index: 100;
            max-height: 80vh;
            overflow-y: auto;
        }

        #control-panel {
            top: 20px;
            left: 20px;
            max-width: 350px;
        }

        #info-panel {
            top: 20px;
            right: 20px;
            max-width: 350px;
        }

        #timeline-controls {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        #gantt-panel {
            bottom: 120px;
            right: 20px;
            max-width: 400px;
            max-height: 400px;
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .control-section h4 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sunburst-controls label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .sunburst-controls input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .gantt-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            border-left: 4px solid;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .gantt-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .gantt-item.requirement { border-left-color: #3B82F6; }
        .gantt-item.deliverable { border-left-color: #10B981; }
        .gantt-item.meeting { border-left-color: #F59E0B; }
        .gantt-item.deadline { border-left-color: #EF4444; }
        .gantt-item.decision { border-left-color: #8B5CF6; }
        .gantt-item.issue { border-left-color: #F97316; }

        .gantt-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .gantt-meta {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
        }

        .timeline-slider {
            width: 400px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            appearance: none;
        }

        .timeline-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(76, 175, 80, 0.5);
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 10px rgba(76, 175, 80, 0.5);
        }

        .control-button {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            font-size: 12px;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .control-button.secondary {
            background: linear-gradient(135deg, #6B7280, #4B5563);
            box-shadow: 0 4px 15px rgba(107, 114, 128, 0.3);
        }

        .control-button.active {
            background: linear-gradient(135deg, #FF6B6B, #EE5A52);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .info-item {
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-label {
            font-size: 12px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            font-size: 16px;
            font-weight: 600;
            margin-top: 3px;
            color: #4CAF50;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 200px;
        }

        .legend h4 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }

        .color-box {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }

        .legend-category {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 10px 0 5px 0;
            opacity: 0.7;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 5px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s ease-in-out infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden { 
            display: none; 
        }

        .error {
            color: #ff6b6b;
            padding: 10px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 8px;
            margin: 10px 0;
        }

        .z-axis-indicator {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 150px;
        }

        .axis-label {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }

        .axis-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 8px;
        }

        /* Hover details panel */
        .details-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 300px;
            z-index: 1000;
        }

        .details-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 8px;
            color: #4CAF50;
        }

        .details-content {
            font-size: 12px;
            line-height: 1.4;
        }

        .details-content .label {
            color: rgba(255, 255, 255, 0.7);
        }

        .details-content .value {
            color: white;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="threejs-container"></div>
        
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div>Loading unified timeline data...</div>
        </div>

        <div id="control-panel" class="panel hidden">
            <h3 style="margin-bottom: 15px; color: #4CAF50;">🎛️ Controls</h3>
            <!-- Database File Controls -->
            <div class="control-section">
                <h4>Data Source</h4>
                <div style="margin-bottom: 10px; font-size: 13px;">
                    <span>Current file: </span><span id="current-db-file" style="font-weight: 600; color: #4CAF50;">unified_timeline.json</span>
                </div>
                <input type="file" id="db-file-input" accept=".json" style="margin-bottom: 10px; color: white; background: rgba(255,255,255,0.05); border-radius: 6px; padding: 6px; border: 1px solid rgba(255,255,255,0.1);" />
                <div id="db-file-error" style="color: #ff6b6b; font-size: 12px; display: none;"></div>
            </div>
            <!-- Timeline Controls -->
            <div class="control-section">
                <h4>Timeline</h4>
                <div class="info-item">
                    <div class="info-label">Current Event</div>
                    <div class="info-value" id="current-event">1 of 1</div>
                </div>
                <div style="margin: 10px 0;">
                    <input type="range" id="timeline-slider" class="timeline-slider" 
                           min="0" max="0" value="0" step="1">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="control-button" id="play-btn">▶ Play</button>
                    <button class="control-button" id="pause-btn">⏸ Pause</button>
                    <button class="control-button" id="reset-btn">⏮ Reset</button>
                    <button class="control-button" id="jump-to-filescan-btn">📁 File Scans</button>
                </div>
            </div>

            <!-- Sunburst Controls -->
            <div class="control-section">
                <h4>Sunburst</h4>
                <label>Min Angle (deg):
                    <input type="range" id="min-angle-slider" min="1" max="50" value="2">
                    <span id="min-angle-value">2</span>
                </label>
                <label>Ring Thickness:
                    <input type="range" id="ring-thickness-slider" min="2" max="20" value="6">
                    <span id="ring-thickness-value">6</span>
                </label>
                <label>Z Spacing:
                    <input type="range" id="z-spacing-slider" min="5" max="50" value="20">
                    <span id="z-spacing-value">20</span>
                </label>
            </div>

            <!-- View Controls -->
            <div class="control-section">
                <h4>View</h4>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <button id="toggle-sunburst" class="control-button">Hide Sunburst</button>
                    <button id="toggle-gantt" class="control-button">Hide Gantt</button>
                    <button id="toggle-connections" class="control-button">Hide Connections</button>
                    <button id="reset-camera" class="control-button secondary">Reset Camera</button>
                </div>
            </div>

            <!-- Generation Controls -->
            <div class="control-section">
                <h4>Generate Timeline</h4>
                <p style="font-size: 12px; opacity: 0.7; margin-bottom: 10px;">
                    Enter local paths to your project folders to generate a command. Run the command in your terminal, then load the generated `unified_timeline.json` file above.
                </p>
                <label for="scan-dir-input" style="font-size: 12px; margin-bottom: 4px; display: block;">Project Folder Path:</label>
                <input type="text" id="scan-dir-input" placeholder="/path/to/project_root" style="width: 100%; padding: 5px; margin-bottom: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: white;">
                
                <label for="email-dir-input" style="font-size: 12px; margin-bottom: 4px; display: block;">Email Folder Path:</label>
                <input type="text" id="email-dir-input" placeholder="/path/to/emails" style="width: 100%; padding: 5px; margin-bottom: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: white;">

                <label for="docs-dir-input" style="font-size: 12px; margin-bottom: 4px; display: block;">Documents Folder Path:</label>
                <input type="text" id="docs-dir-input" placeholder="/path/to/documents" style="width: 100%; padding: 5px; margin-bottom: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: white;">

                <button id="generate-cmd-btn" class="control-button">Generate Command</button>
                
                <textarea id="generated-cmd-output" rows="4" style="width: 100%; margin-top: 15px; background: #0f1419; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #4CAF50; font-family: monospace; font-size: 11px; display: none; padding: 8px;"></textarea>
            </div>
        </div>

        <div id="info-panel" class="panel hidden">
            <h3 style="margin-bottom: 15px; color: #4CAF50;">📊 Timeline Info</h3>
            <div class="info-item">
                <div class="info-label">Current Date</div>
                <div class="info-value" id="current-date">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Event Type</div>
                <div class="info-value" id="event-type">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Total Files</div>
                <div class="info-value" id="total-files">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Active Milestones</div>
                <div class="info-value" id="active-milestones">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Correlations</div>
                <div class="info-value" id="correlations-count">-</div>
            </div>

            <div id="hover-info" style="margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
                <p style="opacity: 0.6; font-size: 12px;"><em>Hover over elements for details</em></p>
            </div>
        </div>

        <div id="gantt-panel" class="panel hidden">
            <h3 style="margin-bottom: 15px; color: #4CAF50;">📅 Milestones</h3>
            <div id="gantt-list"></div>
        </div>

        <div class="legend hidden" id="legend">
            <h4>File Types</h4>
            <div id="legend-content"></div>
        </div>

        <div class="z-axis-indicator hidden" id="z-axis-indicator">
            <h4 style="margin-bottom: 10px; color: #4CAF50;">Inspector View</h4>
            <div class="axis-label">
                <div class="axis-color" style="background: #4CAF50;"></div>
                <span>File Scans</span>
            </div>
            <div class="axis-label">
                <div class="axis-color" style="background: #3B82F6;"></div>
                <span>Milestones</span>
            </div>
            <div style="margin-top: 10px; font-size: 11px; opacity: 0.6;">
                Camera follows timeline<br>
                Vertical inspection<br>
                Focus on current event
            </div>
        </div>

        <div class="details-panel" id="details-panel">
            <div class="details-title" id="details-title">Hover for details</div>
            <div class="details-content" id="details-content"></div>
        </div>
    </div>

    <script>
        class UnifiedTimelineVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.data = null;
                this.currentEventIndex = 0;
                this.isPlaying = false;
                this.playInterval = null;
                this.currentDbFile = 'unified_timeline.json';
                this.userLoadedFile = false;
                this.userCameraPosition = null;
                this.lastUserMove = 0;
                
                // Scene groups
                this.sunburstGroup = new THREE.Group();
                this.sunburstGroup.rotation.x = Math.PI / 2; // Rotate 90 degrees to horizontal
                this.ganttGroup = new THREE.Group();
                this.connectionGroup = new THREE.Group();
                
                // View settings
                this.showSunburst = true;
                this.showGantt = true;
                this.showConnections = true;
                
                // Sunburst parameters
                this.minAngleDeg = 2;
                this.ringThickness = 6;
                this.zSpacing = 20;
                
                // Interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.hoveredObject = null;
                
                // Color mappings
                this.fileColors = {
                    'text/javascript': 0xf7df1e,
                    'application/javascript': 0xf7df1e,
                    'text/x-python': 0x3776ab,
                    'text/html': 0xe34c26,
                    'text/css': 0x1572b6,
                    'application/json': 0x000000,
                    'text/markdown': 0x083fa1,
                    'application/pdf': 0xff0000,
                    'text/plain': 0x9e9e9e,
                    'text/csv': 0x2ecc71,
                    'application/octet-stream': 0x95a5a6,
                    'folder': 0x4CAF50,
                    'default': 0x9e9e9e
                };
                
                this.milestoneColors = {
                    'requirement': 0x3B82F6,
                    'deliverable': 0x10B981,
                    'meeting': 0xF59E0B,
                    'deadline': 0xEF4444,
                    'decision': 0x8B5CF6,
                    'issue': 0xF97316,
                    'default': 0x6B7280
                };
                
                this.init();
            }

            async init() {
                this.setupScene();
                this.setupEventListeners();
                await this.loadData();
                this.createVisualization();
                this.animate();
                
                this.hideLoading();
                this.showPanels();
            }

            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                
                // Remove solid background color for lightbox effect
                // this.scene.background = new THREE.Color(0x0a0e14);

                // Camera - Inspector view that follows timeline vertically
                this.camera = new THREE.PerspectiveCamera(
                    60, 
                    window.innerWidth / window.innerHeight, 
                    1, 
                    20000
                );
                // Initial camera position - will be updated based on current event
                this.camera.position.set(2.5, 30, 80);
                this.camera.lookAt(2.5, 0, 0);

                // Renderer with enhanced settings for lightbox effect
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    preserveDrawingBuffer: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x000000, 0); // Transparent background
                document.getElementById('threejs-container').appendChild(this.renderer.domElement);

                // Enhanced lighting system for lightbox effect
                this.setupLightboxLighting();

                // Add background elements for depth
                this.createBackgroundElements();

                // Add groups to scene
                this.scene.add(this.sunburstGroup);
                this.scene.add(this.ganttGroup);
                this.scene.add(this.connectionGroup);

                // Setup orbit controls
                this.setupOrbitControls();
            }

            setupLightboxLighting() {
                // Remove existing lights
                const lightsToRemove = [];
                this.scene.children.forEach(child => {
                    if (child.isLight) {
                        lightsToRemove.push(child);
                    }
                });
                lightsToRemove.forEach(light => this.scene.remove(light));

                // Create lightbox lighting setup
                
                // 1. Subtle ambient light for base illumination
                const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
                this.scene.add(ambientLight);

                // 2. Main directional light (like a spotlight)
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainLight.position.set(50, 100, 50);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                mainLight.shadow.camera.near = 0.5;
                mainLight.shadow.camera.far = 500;
                mainLight.shadow.camera.left = -100;
                mainLight.shadow.camera.right = 100;
                mainLight.shadow.camera.top = 100;
                mainLight.shadow.camera.bottom = -100;
                this.scene.add(mainLight);

                // 3. Fill light from opposite direction
                const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.4);
                fillLight.position.set(-30, 50, -30);
                this.scene.add(fillLight);

                // 4. Rim light for edge definition
                const rimLight = new THREE.DirectionalLight(0xff6b6b, 0.3);
                rimLight.position.set(0, -50, 100);
                this.scene.add(rimLight);

                // 5. Point lights for dramatic effect
                const pointLight1 = new THREE.PointLight(0x4CAF50, 0.6, 200);
                pointLight1.position.set(-20, 30, 50);
                this.scene.add(pointLight1);

                const pointLight2 = new THREE.PointLight(0x3B82F6, 0.4, 150);
                pointLight2.position.set(30, 20, -30);
                this.scene.add(pointLight2);

                // 6. Subtle hemisphere light for environmental lighting
                const hemisphereLight = new THREE.HemisphereLight(0x4a90e2, 0x1a1a2e, 0.2);
                this.scene.add(hemisphereLight);
            }

            createBackgroundElements() {
                // Create a large ground plane for shadows and depth
                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: 0x0a0e14,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -50;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Create subtle grid lines for depth perception
                const gridHelper = new THREE.GridHelper(200, 20, 0x2a2a2a, 0x1a1a1a);
                gridHelper.position.y = -49;
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.3;
                this.scene.add(gridHelper);

                // Create distant background planes for atmospheric depth
                this.createAtmosphericBackground();
            }

            createAtmosphericBackground() {
                // Back wall
                const backWallGeometry = new THREE.PlaneGeometry(800, 400);
                const backWallMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0a0e14,
                    transparent: true,
                    opacity: 0.05,
                    side: THREE.DoubleSide
                });
                const backWall = new THREE.Mesh(backWallGeometry, backWallMaterial);
                backWall.position.z = -200;
                this.scene.add(backWall);

                // Side walls for enclosure effect
                const sideWallGeometry = new THREE.PlaneGeometry(400, 400);
                const sideWallMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0a0e14,
                    transparent: true,
                    opacity: 0.03,
                    side: THREE.DoubleSide
                });

                const leftWall = new THREE.Mesh(sideWallGeometry, sideWallMaterial);
                leftWall.position.x = -200;
                leftWall.rotation.y = Math.PI / 2;
                this.scene.add(leftWall);

                const rightWall = new THREE.Mesh(sideWallGeometry, sideWallMaterial);
                rightWall.position.x = 200;
                rightWall.rotation.y = -Math.PI / 2;
                this.scene.add(rightWall);

                // Add subtle fog for atmospheric depth
                this.scene.fog = new THREE.Fog(0x0a0e14, 100, 800);
            }

            setupOrbitControls() {
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.enableZoom = true;
                this.controls.autoRotate = false;
                this.controls.autoRotateSpeed = 0.5;
                
                // Allow some movement for inspector view while maintaining focus
                this.controls.enablePan = true; // Enable panning for user control
                this.controls.minDistance = 30; // Minimum zoom distance
                this.controls.maxDistance = 150; // Maximum zoom distance
                this.controls.minPolarAngle = Math.PI / 6; // Allow more vertical rotation
                this.controls.maxPolarAngle = Math.PI / 2; // Limit vertical rotation
                
                // Add event listener to update camera position when user manually moves camera
                this.controls.addEventListener('change', () => {
                    // Store user's manual camera position for reference
                    this.userCameraPosition = this.camera.position.clone();
                    this.lastUserMove = Date.now();
                });
            }

            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());

                // Mouse interaction
                this.renderer.domElement.addEventListener('mousemove', (event) => this.onMouseMove(event));
                this.renderer.domElement.addEventListener('mouseleave', () => this.hideHoverPanel());

                // Timeline controls
                document.getElementById('timeline-slider').addEventListener('input', (e) => {
                    this.setCurrentEvent(parseInt(e.target.value));
                });

                document.getElementById('play-btn').addEventListener('click', () => this.play());
                document.getElementById('pause-btn').addEventListener('click', () => this.pause());
                document.getElementById('reset-btn').addEventListener('click', () => this.reset());
                document.getElementById('jump-to-filescan-btn').addEventListener('click', () => this.jumpToFileScan());

                // Sunburst controls
                this.setupSunburstControls();

                // View controls
                document.getElementById('toggle-sunburst').addEventListener('click', () => this.toggleSunburst());
                document.getElementById('toggle-gantt').addEventListener('click', () => this.toggleGantt());
                document.getElementById('toggle-connections').addEventListener('click', () => this.toggleConnections());
                document.getElementById('reset-camera').addEventListener('click', () => this.resetCamera());

                // Database file input
                document.getElementById('db-file-input').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadCustomDbFile(file);
                    }
                });

                // Command generator
                document.getElementById('generate-cmd-btn').addEventListener('click', () => this.generateBackendCommand());
            }

            setupSunburstControls() {
                const minAngleSlider = document.getElementById('min-angle-slider');
                const minAngleValue = document.getElementById('min-angle-value');
                minAngleSlider.addEventListener('input', (e) => {
                    this.minAngleDeg = parseInt(e.target.value);
                    minAngleValue.textContent = this.minAngleDeg;
                    this.updateVisualization();
                });

                const ringThicknessSlider = document.getElementById('ring-thickness-slider');
                const ringThicknessValue = document.getElementById('ring-thickness-value');
                ringThicknessSlider.addEventListener('input', (e) => {
                    this.ringThickness = parseInt(e.target.value);
                    ringThicknessValue.textContent = this.ringThickness;
                    this.updateVisualization();
                });

                const zSpacingSlider = document.getElementById('z-spacing-slider');
                const zSpacingValue = document.getElementById('z-spacing-value');
                zSpacingSlider.addEventListener('input', (e) => {
                    this.zSpacing = parseInt(e.target.value);
                    zSpacingValue.textContent = this.zSpacing;
                    this.updateVisualization();
                });
            }

            async loadData() {
                try {
                    console.log('Loading data from:', this.currentDbFile);
                    const response = await fetch(this.currentDbFile);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    this.data = await response.json();
                    console.log('Data loaded successfully:', {
                        hasData: !!this.data,
                        hasEvents: !!(this.data && this.data.events),
                        eventCount: this.data && this.data.events ? this.data.events.length : 0,
                        eventTypes: this.data && this.data.metadata ? this.data.metadata.event_types : {},
                        fileScanCount: this.data && this.data.events ? this.data.events.filter(e => e.event_type === 'file_scan').length : 0
                    });
                    document.getElementById('current-db-file').textContent = this.currentDbFile;
                    this.initializeTimeline();
                } catch (error) {
                    console.error('Error loading data:', error);
                    this.showError(`Failed to load data: ${error.message}`);
                    // Only generate sample data if not user-initiated
                    if (!this.userLoadedFile) {
                        this.generateSampleData();
                    }
                }
            }

            async loadCustomDbFile(file) {
                try {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            this.data = JSON.parse(e.target.result);
                            this.currentDbFile = file.name;
                            this.userLoadedFile = true;
                            document.getElementById('current-db-file').textContent = file.name;
                            document.getElementById('db-file-error').style.display = 'none';
                            this.initializeTimeline();
                        } catch (parseErr) {
                            document.getElementById('db-file-error').textContent = 'Invalid JSON file.';
                            document.getElementById('db-file-error').style.display = 'block';
                        }
                    };
                    reader.readAsText(file);
                } catch (error) {
                    document.getElementById('db-file-error').textContent = 'Failed to load file.';
                    document.getElementById('db-file-error').style.display = 'block';
                }
            }

            generateBackendCommand() {
                const scanDir = document.getElementById('scan-dir-input').value.trim();
                const emailDir = document.getElementById('email-dir-input').value.trim();
                const docsDir = document.getElementById('docs-dir-input').value.trim();
                const outputArea = document.getElementById('generated-cmd-output');

                let command = 'python unified_backend.py';
                if (scanDir) {
                    command += ` --scan-dir "${scanDir}"`;
                }
                if (emailDir) {
                    command += ` --email-dir "${emailDir}"`;
                }
                if (docsDir) {
                    command += ` --docs-dir "${docsDir}"`;
                }
                command += ' --correlate --output unified_timeline.json';

                if (!scanDir && !emailDir && !docsDir) {
                    outputArea.value = 'Please provide at least one directory path.';
                } else {
                    outputArea.value = command;
                }
                
                outputArea.style.display = 'block';
            }


            initializeTimeline() {
                console.log('Initializing timeline with data:', {
                    hasData: !!this.data,
                    hasEvents: !!(this.data && this.data.events),
                    eventCount: this.data && this.data.events ? this.data.events.length : 0
                });
                
                if (!this.data || !this.data.events || this.data.events.length === 0) {
                    this.showError('No timeline data available');
                    return;
                }

                const slider = document.getElementById('timeline-slider');
                slider.max = this.data.events.length - 1;
                
                // Start at the end to show all events including file_scan events
                this.currentEventIndex = this.data.events.length - 1;
                slider.value = this.currentEventIndex;
                
                console.log('Timeline initialized, calling updateVisualization');
                this.updateVisualization();
                this.updateInfo();
                this.updateGanttChart();
                this.updateLegend();
                this.updateCameraPosition();
            }

            createVisualization() {
                this.updateVisualization();
            }

            updateVisualization() {
                // Clear existing visualization
                this.clearGroups();

                if (!this.data || !this.data.events) {
                    console.log('No data or events available');
                    return;
                }

                // Show events up to current index
                const eventsToShow = this.data.events.slice(0, this.currentEventIndex + 1);
                console.log('updateVisualization called:', {
                    totalEvents: this.data.events.length,
                    currentEventIndex: this.currentEventIndex,
                    eventsToShow: eventsToShow.length,
                    showSunburst: this.showSunburst,
                    showGantt: this.showGantt,
                    showConnections: this.showConnections
                });
                
                if (this.showSunburst) {
                    this.createSunburstVisualization(eventsToShow);
                }
                
                if (this.showGantt) {
                    this.createGanttVisualization(eventsToShow);
                }

                if (this.showConnections) {
                    this.createConnections(eventsToShow);
                }

                this.updateInfo();
                document.getElementById('current-event').textContent = 
                    `${this.currentEventIndex + 1} of ${this.data.events.length}`;
            }

            clearGroups() {
                [this.sunburstGroup, this.ganttGroup, this.connectionGroup].forEach(group => {
                    while (group.children.length > 0) {
                        group.remove(group.children[0]);
                    }
                });
            }

            createSunburstVisualization(events) {
                console.log('Creating sunburst visualization for events:', events.length);
                const fileScanEvents = events.filter(e => e.event_type === 'file_scan');
                console.log('File scan events found:', fileScanEvents.length);
                
                events.forEach((event, index) => {
                    console.log(`Processing event ${index}:`, {
                        eventType: event.event_type,
                        hasTreeStructure: !!(event.metadata && event.metadata.tree_structure),
                        treeStructureKeys: event.metadata && event.metadata.tree_structure ? Object.keys(event.metadata.tree_structure) : []
                    });
                    
                    if (event.event_type === 'file_scan' && event.metadata.tree_structure) {
                        // Position all events at the same Z position (centered) - timeline scrolls by
                        const zPosition = 0; // Fixed center position
                        console.log(`Creating sunburst for file_scan event at index ${index}, zPosition ${zPosition}`);
                        this.createSunburstAtPosition(event.metadata.tree_structure, zPosition, index);
                        this.createTimeLabel(event.timestamp, zPosition, 'file_scan');
                    }
                });
            }

            createSunburstAtPosition(treeData, zPosition, eventIndex) {
                console.log('Creating sunburst at position:', {
                    zPosition: zPosition,
                    eventIndex: eventIndex,
                    treeData: treeData,
                    treeDataKeys: Object.keys(treeData || {}),
                    hasChildren: !!(treeData && treeData.children),
                    childrenCount: treeData && treeData.children ? treeData.children.length : 0
                });
                
                // Position sunburst at the center, close to milestones
                const sunburstX = 0; // Center position
                
                this.createSunburstRecursive(
                    treeData, 
                    0, 
                    Math.PI * 2, 
                    5, 
                    0, 
                    new THREE.Vector3(sunburstX, 0, zPosition), 
                    eventIndex
                );
            }

            createSunburstRecursive(node, startAngle, endAngle, innerRadius, outerRadius, position, eventIndex) {
                const angleSpan = endAngle - startAngle;
                const radius = outerRadius || innerRadius + this.ringThickness;
                const opacity = Math.max(0.6, 1 - eventIndex * 0.05);
                
                // Handle the actual data structure from unified_timeline.json
                // Root node has properties directly, children have type/data structure
                const nodeData = node.data || node;
                const nodeType = node.type || (nodeData.type || 'folder'); // Default to folder for root
                const nodeName = nodeData.name || node.name || 'Unknown';
                const nodeSize = nodeData.size || node.size || 1;
                const nodeMimeType = nodeData.mime_type || node.mime_type;
                    
                // Create ring segment
                const geometry = new THREE.RingGeometry(
                    innerRadius, 
                    radius, 
                    32, 
                    1, 
                    startAngle, 
                    angleSpan
                );
                
                // Debug statement for sunburst creation
                console.log('Creating sunburst segment:', {
                    nodeType: nodeType,
                    nodeName: nodeName,
                    nodeSize: nodeSize,
                    nodeMimeType: nodeMimeType,
                    startAngle: startAngle.toFixed(3),
                    endAngle: endAngle.toFixed(3), 
                    angleSpan: angleSpan.toFixed(3),
                    innerRadius: innerRadius.toFixed(1),
                    outerRadius: radius.toFixed(1),
                    position: {
                        x: position.x.toFixed(1),
                        y: position.y.toFixed(1), 
                        z: position.z.toFixed(1)
                    },
                    eventIndex: eventIndex,
                    opacity: opacity.toFixed(2)
                });
                
                // Get color based on type and mime_type
                let color;
                if (nodeType === 'folder') {
                    color = this.fileColors.folder;
                } else {
                    color = this.fileColors[nodeMimeType] || this.fileColors.default;
                }

                const material = new THREE.MeshLambertMaterial({
                    color: color,
                    transparent: true,
                    opacity: opacity,
                    side: THREE.DoubleSide,
                    emissive: new THREE.Color(color).multiplyScalar(0.1),
                    emissiveIntensity: 0.2
                });

                const ring = new THREE.Mesh(geometry, material);
                ring.position.copy(position);
                ring.userData = { 
                    node: nodeData, 
                    type: 'sunburst', 
                    eventIndex: eventIndex,
                    originalOpacity: opacity
                };
                
                this.sunburstGroup.add(ring);

                // Process children - handle the actual data structure
                // Root node has children directly, child nodes have children in their data
                const children = node.children || nodeData.children || [];
                if (children && children.length > 0) {
                    const totalValue = children.reduce((sum, child) => {
                        const childData = child.data || child;
                        return sum + (childData.size || 1);
                    }, 0);
                    
                    let currentAngle = startAngle;
                    const minAngleRad = this.minAngleDeg * Math.PI / 180;

                    children.forEach(child => {
                        const childData = child.data || child;
                        const childSize = childData.size || 1;
                        const childAngleSpan = Math.max(minAngleRad, (childSize / totalValue) * angleSpan);
                        
                        this.createSunburstRecursive(
                            child, // Pass the original child object to preserve structure
                            currentAngle,
                            currentAngle + childAngleSpan,
                            radius + 2,
                            radius + 2 + this.ringThickness,
                            position,
                            eventIndex
                        );
                        
                        currentAngle += childAngleSpan;
                    });
                }
            }

            createGanttVisualization(events) {
                const milestoneEvents = events.filter(e => e.event_type === 'milestone');
                const ganttX = 5; // Position very close to sunburst (was 25)
                
                milestoneEvents.forEach((event, index) => {
                    const milestone = event.metadata;
                    // Position all events at the same Z position (centered) - timeline scrolls by
                    const zPosition = 0; // Fixed center position
                    const yPosition = index * 12; // Reduce vertical spacing (was 15)
                    
                    this.createMilestoneBar3D(milestone, ganttX, yPosition, zPosition, event.event_id);
                });
            }

            createMilestoneBar3D(milestone, x, y, z, eventId) {
                const color = this.milestoneColors[milestone.category] || this.milestoneColors.default;
                
                // Create milestone bar - slightly smaller for better balance
                const geometry = new THREE.BoxGeometry(8, 3, 6); // Reduced from 12, 4, 8
                const material = new THREE.MeshLambertMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9,
                    emissive: new THREE.Color(color).multiplyScalar(0.15),
                    emissiveIntensity: 0.3,
                    shininess: 30
                });

                const bar = new THREE.Mesh(geometry, material);
                bar.position.set(x, y, z);
                bar.userData = { 
                    milestone: milestone, 
                    type: 'milestone',
                    eventId: eventId
                };
                bar.castShadow = true;

                this.ganttGroup.add(bar);

                // Add milestone marker - slightly smaller
                const markerGeometry = new THREE.SphereGeometry(1.5); // Reduced from 2
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: milestone.priority === 'critical' ? 0xFF0000 : color,
                    transparent: true,
                    opacity: 0.9
                });
                
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(x - 6, y, z); // Adjusted position for smaller bar
                marker.userData = { 
                    milestone: milestone, 
                    type: 'milestone_marker',
                    eventId: eventId
                };
                
                this.ganttGroup.add(marker);

                // Add text label
                this.createTextLabel(milestone.title, x + 6, y + 4, z); // Adjusted position
            }

            createTextLabel(text, x, y, z) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                
                context.fillStyle = '#ffffff';
                context.font = 'bold 12px Arial'; // Slightly smaller font
                context.fillText(text.substring(0, 20), 10, 30);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const geometry = new THREE.PlaneGeometry(12, 3); // Smaller text plane
                const textMesh = new THREE.Mesh(geometry, material);
                
                textMesh.position.set(x, y, z);
                textMesh.lookAt(this.camera.position);
                
                this.ganttGroup.add(textMesh);
            }

            createTimeLabel(timestamp, z, eventType) {
                const date = new Date(timestamp * 1000);
                const dateStr = date.toLocaleDateString();
                
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 32;
                const context = canvas.getContext('2d');
                
                context.fillStyle = eventType === 'file_scan' ? '#4CAF50' : '#3B82F6';
                context.font = '12px Arial';
                context.fillText(dateStr, 10, 20);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const geometry = new THREE.PlaneGeometry(8, 2);
                const label = new THREE.Mesh(geometry, material);
                
                // Position label to align with sunburst
                label.position.set(-15, 0, z); // Moved to align with sunburst at X=0
                label.lookAt(this.camera.position);
                
                this.sunburstGroup.add(label);
            }

            createConnections(events) {
                if (!this.data.correlations) return;

                this.data.correlations.forEach(correlation => {
                    const fileEvent = events.find(e => e.event_id === correlation.file_event_id);
                    const milestoneEvent = events.find(e => e.event_id === correlation.milestone_event_id);
                    
                    if (fileEvent && milestoneEvent) {
                        // All events are at the same Z position now
                        const zPosition = 0; // Fixed center position
                        
                        this.createConnectionLine(
                            new THREE.Vector3(0, 0, zPosition), // Sunburst position
                            new THREE.Vector3(5, 0, zPosition), // Milestone position
                            correlation.correlation_strength
                        );
                    }
                });
            }

            createConnectionLine(startPos, endPos, strength) {
                const geometry = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                const material = new THREE.LineBasicMaterial({
                    color: 0xF59E0B,
                    transparent: true,
                    opacity: strength * 0.8
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { type: 'connection', strength: strength };
                
                this.connectionGroup.add(line);
            }

            updateGanttChart() {
                const ganttList = document.getElementById('gantt-list');
                ganttList.innerHTML = '';

                if (!this.data || !this.data.events) return;

                const milestoneEvents = this.data.events
                    .filter(e => e.event_type === 'milestone')
                    .slice(0, this.currentEventIndex + 1);

                milestoneEvents.forEach(event => {
                    const milestone = event.metadata;
                    const item = document.createElement('div');
                    item.className = `gantt-item ${milestone.category}`;
                    
                    item.innerHTML = `
                        <div class="gantt-title">${milestone.title}</div>
                        <div class="gantt-meta">
                            <span>${milestone.priority.toUpperCase()}</span>
                            <span>${milestone.confidence.toFixed(1)}</span>
                        </div>
                    `;
                    
                    item.addEventListener('click', () => {
                        this.focusOnMilestone(event);
                    });
                    
                    ganttList.appendChild(item);
                });
            }

            updateInfo() {
                if (!this.data || !this.data.events) return;

                const currentEvent = this.data.events[this.currentEventIndex];
                
                document.getElementById('current-date').textContent = 
                    new Date(currentEvent.timestamp * 1000).toLocaleDateString();
                document.getElementById('event-type').textContent = 
                    currentEvent.event_type.replace('_', ' ').toUpperCase();
                
                if (currentEvent.event_type === 'file_scan') {
                    document.getElementById('total-files').textContent = 
                        currentEvent.metadata.file_count || 0;
                } else {
                    // Calculate cumulative files from previous file scans
                    let totalFiles = 0;
                    for (let i = 0; i <= this.currentEventIndex; i++) {
                        const event = this.data.events[i];
                        if (event.event_type === 'file_scan') {
                            totalFiles = event.metadata.file_count || 0;
                        }
                    }
                    document.getElementById('total-files').textContent = totalFiles;
                }

                const activeMilestones = this.data.events
                    .slice(0, this.currentEventIndex + 1)
                    .filter(e => e.event_type === 'milestone').length;
                document.getElementById('active-milestones').textContent = activeMilestones;

                document.getElementById('correlations-count').textContent = 
                    this.data.correlations ? this.data.correlations.length : 0;
            }

            updateLegend() {
                const legendContent = document.getElementById('legend-content');
                const categories = {
                    'Programming': ['text/javascript', 'text/x-python', 'text/html', 'text/css'],
                    'Documents': ['application/json', 'text/markdown', 'application/pdf'],
                    'Other': ['folder', 'default']
                };

                let html = '';
                for (const [category, types] of Object.entries(categories)) {
                    html += `<div class="legend-category">${category}</div>`;
                    types.forEach(type => {
                        const color = this.fileColors[type];
                        const label = type.split('/').pop()
                            .replace('javascript', 'JavaScript')
                            .replace('x-python', 'Python')
                            .replace('html', 'HTML')
                            .replace('css', 'CSS')
                            .replace('json', 'JSON')
                            .replace('markdown', 'Markdown')
                            .replace('pdf', 'PDF')
                            .replace('folder', 'Folders')
                            .replace('default', 'Other');
                        
                        html += `
                            <div class="legend-item">
                                <div class="color-box" style="background-color: #${color.toString(16).padStart(6, '0')};"></div>
                                <span>${label}</span>
                            </div>
                        `;
                    });
                }
                legendContent.innerHTML = html;
            }

            onMouseMove(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                const allObjects = [
                    ...this.sunburstGroup.children,
                    ...this.ganttGroup.children,
                    ...this.connectionGroup.children
                ];
                
                const intersects = this.raycaster.intersectObjects(allObjects);

                // Reset opacity for all objects
                allObjects.forEach(obj => {
                    if (obj.material && obj.userData.originalOpacity !== undefined) {
                        obj.material.opacity = obj.userData.originalOpacity;
                    }
                });

                if (intersects.length > 0) {
                    const intersected = intersects[0].object;
                    
                    // Highlight hovered object
                    if (intersected.material) {
                        intersected.material.opacity = 1.0;
                    }
                    
                    this.showHoverPanel(intersected, event.clientX, event.clientY);
                    this.hoveredObject = intersected;
                } else {
                    this.hideHoverPanel();
                    this.hoveredObject = null;
                }
            }

            showHoverPanel(object, x, y) {
                const panel = document.getElementById('details-panel');
                const title = document.getElementById('details-title');
                const content = document.getElementById('details-content');
                
                let titleText = 'Unknown';
                let contentText = '';

                if (object.userData.node) {
                    const node = object.userData.node;
                    titleText = node.name || 'File/Folder';
                    contentText = `
                        <div><span class="label">Type:</span> <span class="value">${node.type || 'file'}</span></div>
                        <div><span class="label">Size:</span> <span class="value">${this.formatBytes(node.size || 0)}</span></div>
                        ${node.mime_type ? `<div><span class="label">MIME:</span> <span class="value">${node.mime_type}</span></div>` : ''}
                    `;
                } else if (object.userData.milestone) {
                    const milestone = object.userData.milestone;
                    titleText = milestone.title || 'Milestone';
                    contentText = `
                        <div><span class="label">Category:</span> <span class="value">${milestone.category}</span></div>
                        <div><span class="label">Priority:</span> <span class="value">${milestone.priority}</span></div>
                        <div><span class="label">Confidence:</span> <span class="value">${(milestone.confidence * 100).toFixed(0)}%</span></div>
                        <div style="margin-top: 8px;"><span class="value">${milestone.description}</span></div>
                    `;
                } else if (object.userData.type === 'connection') {
                    titleText = 'Correlation';
                    contentText = `
                        <div><span class="label">Strength:</span> <span class="value">${(object.userData.strength * 100).toFixed(0)}%</span></div>
                        <div><span class="value">Links file changes to milestones</span></div>
                    `;
                }

                title.textContent = titleText;
                content.innerHTML = contentText;
                
                panel.style.left = `${Math.min(x + 20, window.innerWidth - 320)}px`;
                panel.style.top = `${Math.min(y + 20, window.innerHeight - 200)}px`;
                panel.style.opacity = '1';
            }

            hideHoverPanel() {
                const panel = document.getElementById('details-panel');
                panel.style.opacity = '0';
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            focusOnMilestone(milestoneEvent) {
                const eventIndex = this.data.events.indexOf(milestoneEvent);
                if (eventIndex !== -1) {
                    this.setCurrentEvent(eventIndex);
                    
                    // Inspector view - camera will automatically position to the milestone
                    this.updateCameraPosition();
                }
            }

            animateCameraTo(position, target) {
                const startPosition = this.camera.position.clone();
                const endPosition = position.clone();
                
                let progress = 0;
                const animate = () => {
                    progress += 0.02;
                    
                    if (progress <= 1) {
                        this.camera.position.lerpVectors(startPosition, endPosition, progress);
                        this.camera.lookAt(target);
                        requestAnimationFrame(animate);
                    } else {
                        this.controls.target.copy(target);
                        this.controls.update();
                    }
                };
                
                animate();
            }

            play() {
                if (this.isPlaying) return;
                
                this.isPlaying = true;
                document.getElementById('play-btn').classList.add('active');
                
                this.playInterval = setInterval(() => {
                    if (this.currentEventIndex < this.data.events.length - 1) {
                        this.setCurrentEvent(this.currentEventIndex + 1);
                    } else {
                        this.pause();
                    }
                }, 2000);
            }

            pause() {
                this.isPlaying = false;
                document.getElementById('play-btn').classList.remove('active');
                
                if (this.playInterval) {
                    clearInterval(this.playInterval);
                    this.playInterval = null;
                }
            }

            reset() {
                this.pause();
                this.setCurrentEvent(0);
                this.resetCamera();
            }

            setCurrentEvent(index) {
                if (!this.data || index < 0 || index >= this.data.events.length) {
                    console.log('Invalid event index:', index);
                    return;
                }
                
                console.log(`Setting current event to index ${index}:`, {
                    eventType: this.data.events[index].event_type,
                    eventId: this.data.events[index].event_id,
                    timestamp: this.data.events[index].timestamp
                });
                
                this.currentEventIndex = index;
                document.getElementById('timeline-slider').value = index;
                this.updateVisualization();
                this.updateGanttChart();
                this.updateCameraPosition();
            }

            toggleSunburst() {
                this.showSunburst = !this.showSunburst;
                const button = document.getElementById('toggle-sunburst');
                button.textContent = this.showSunburst ? 'Hide Sunburst' : 'Show Sunburst';
                this.sunburstGroup.visible = this.showSunburst;
            }

            toggleGantt() {
                this.showGantt = !this.showGantt;
                const button = document.getElementById('toggle-gantt');
                button.textContent = this.showGantt ? 'Hide Gantt' : 'Show Gantt';
                this.ganttGroup.visible = this.showGantt;
            }

            toggleConnections() {
                this.showConnections = !this.showConnections;
                const button = document.getElementById('toggle-connections');
                button.textContent = this.showConnections ? 'Hide Connections' : 'Show Connections';
                this.connectionGroup.visible = this.showConnections;
            }

            resetCamera() {
                // Inspector view - update camera position based on current event
                this.userCameraPosition = null; // Reset user camera position
                this.lastUserMove = 0; // Reset user move timestamp
                this.updateCameraPosition();
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            hideLoading() {
                document.getElementById('loading').classList.add('hidden');
            }

            showPanels() {
                document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('hidden'));
                document.getElementById('legend').classList.remove('hidden');
                document.getElementById('z-axis-indicator').classList.remove('hidden');
            }

            showError(message) {
                const loading = document.getElementById('loading');
                loading.innerHTML = `<div class="error">Error: ${message}</div>`;
                console.error('Visualizer Error:', message);
            }

            jumpToFileScan() {
                if (!this.data || !this.data.events) return;
                
                // Find the last file_scan event to show all file_scan events
                let lastFileScanIndex = -1;
                for (let i = this.data.events.length - 1; i >= 0; i--) {
                    if (this.data.events[i].event_type === 'file_scan') {
                        lastFileScanIndex = i;
                        break;
                    }
                }
                
                if (lastFileScanIndex !== -1) {
                    console.log(`Jumping to last file_scan event at index ${lastFileScanIndex}`);
                    this.setCurrentEvent(lastFileScanIndex);
                } else {
                    console.log('No file_scan events found in timeline');
                }
            }

            updateCameraPosition() {
                if (!this.data || !this.data.events || this.currentEventIndex < 0) {
                    return;
                }

                // Find all milestones and file scans up to and including the current event
                const eventsUpToCurrent = this.data.events.slice(0, this.currentEventIndex + 1);
                const milestoneEvents = eventsUpToCurrent.filter(e => e.event_type === 'milestone');
                const fileScanEvents = eventsUpToCurrent.filter(e => e.event_type === 'file_scan');

                // Find the Y position for the current event
                let targetY = 0;
                const currentEvent = this.data.events[this.currentEventIndex];
                if (currentEvent.event_type === 'milestone' && milestoneEvents.length > 0) {
                    // Center on the current milestone
                    const milestoneIndex = milestoneEvents.length - 1;
                    targetY = milestoneIndex * 12;
                } else if (currentEvent.event_type === 'file_scan' && fileScanEvents.length > 0) {
                    // Center on the current file scan
                    const fileScanIndex = fileScanEvents.length - 1;
                    targetY = fileScanIndex * 12;
                } else if (milestoneEvents.length > 0) {
                    // Center on the last milestone before current event
                    const milestoneIndex = milestoneEvents.length - 1;
                    targetY = milestoneIndex * 12;
                } else if (fileScanEvents.length > 0) {
                    // Center on the last file scan before current event
                    const fileScanIndex = fileScanEvents.length - 1;
                    targetY = fileScanIndex * 12;
                } else {
                    // No milestones or file scans yet, default to 0
                    targetY = 0;
                }

                // Set camera and controls target directly
                this.camera.position.set(2.5, targetY + 30, 80);
                this.controls.target.set(2.5, targetY, 0);
                this.camera.lookAt(this.controls.target);
                this.controls.update();
            }
        }

        // Initialize the visualizer when the page loads
        window.addEventListener('load', () => {
            new UnifiedTimelineVisualizer();
        });
    </script>
</body>
</html>